<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>DPDK: lib/librte_hash/rte_hash.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_fcaecf9e47d3074427ceb27ca105ed74.html">lib</a></li><li class="navelem"><a class="el" href="dir_2c5725aee7eba1450e3c418af6321460.html">librte_hash</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_hash.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;sys/queue.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__hash__parameters.html">rte_hash_parameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__hash.html">rte_hash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a080e28e97cdd08dddfee7fc49084c0f4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a080e28e97cdd08dddfee7fc49084c0f4">RTE_HASH_ENTRIES_MAX</a>&#160;&#160;&#160;(1 &lt;&lt; 26)</td></tr>
<tr class="separator:a080e28e97cdd08dddfee7fc49084c0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6aad50c1c5af42b9fe1210bb7edb2e7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#af6aad50c1c5af42b9fe1210bb7edb2e7">RTE_HASH_BUCKET_ENTRIES_MAX</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:af6aad50c1c5af42b9fe1210bb7edb2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9a7a326415377f904b9e323abd5dbc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#adc9a7a326415377f904b9e323abd5dbc">RTE_HASH_KEY_LENGTH_MAX</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:adc9a7a326415377f904b9e323abd5dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d9cbb1b31cf0a18427128378bc94ec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a40d9cbb1b31cf0a18427128378bc94ec">RTE_HASH_LOOKUP_BULK_MAX</a>&#160;&#160;&#160;16</td></tr>
<tr class="separator:a40d9cbb1b31cf0a18427128378bc94ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2eca61b3180fccd47b5170fa115d48"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a6f2eca61b3180fccd47b5170fa115d48">RTE_HASH_NAMESIZE</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:a6f2eca61b3180fccd47b5170fa115d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab9cf833d6d86f042b9ac01ae2e5b998f"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a></td></tr>
<tr class="separator:ab9cf833d6d86f042b9ac01ae2e5b998f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b12fdd40a9aa9aa254d45b052e57350"><td class="memItemLeft" align="right" valign="top">typedef uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a1b12fdd40a9aa9aa254d45b052e57350">rte_hash_function</a>) (const void *key, uint32_t key_len, uint32_t init_val)</td></tr>
<tr class="separator:a1b12fdd40a9aa9aa254d45b052e57350"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5afbd2564f738149a241bc22b2428612"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a5afbd2564f738149a241bc22b2428612">rte_hash_create</a> (const struct <a class="el" href="structrte__hash__parameters.html">rte_hash_parameters</a> *params)</td></tr>
<tr class="separator:a5afbd2564f738149a241bc22b2428612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c3876597e47c045c945d78e0e1d332"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a04c3876597e47c045c945d78e0e1d332">rte_hash_find_existing</a> (const char *name)</td></tr>
<tr class="separator:a04c3876597e47c045c945d78e0e1d332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b82800460ad6918b822db30d1c21f77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a2b82800460ad6918b822db30d1c21f77">rte_hash_free</a> (struct <a class="el" href="structrte__hash.html">rte_hash</a> *h)</td></tr>
<tr class="separator:a2b82800460ad6918b822db30d1c21f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0247f58baa6cbf614e5b729ff0baf27e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a0247f58baa6cbf614e5b729ff0baf27e">rte_hash_add_key</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const void *key)</td></tr>
<tr class="separator:a0247f58baa6cbf614e5b729ff0baf27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa426cfe49f1b6750cf35e932bb55067"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#aaa426cfe49f1b6750cf35e932bb55067">rte_hash_add_key_with_hash</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const void *key, <a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a> sig)</td></tr>
<tr class="separator:aaa426cfe49f1b6750cf35e932bb55067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa125f9c9f57ea5fdf2752bcb506a058"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#aaa125f9c9f57ea5fdf2752bcb506a058">rte_hash_del_key</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const void *key)</td></tr>
<tr class="separator:aaa125f9c9f57ea5fdf2752bcb506a058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da9abc1a395e6891d5f5d0f2ac69cf7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a0da9abc1a395e6891d5f5d0f2ac69cf7">rte_hash_del_key_with_hash</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const void *key, <a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a> sig)</td></tr>
<tr class="separator:a0da9abc1a395e6891d5f5d0f2ac69cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ff0b837d39bbff00863feabf15e224"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a62ff0b837d39bbff00863feabf15e224">rte_hash_lookup</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const void *key)</td></tr>
<tr class="separator:a62ff0b837d39bbff00863feabf15e224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf0a56da3a957a113ea1bfedd78c7e6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a8bf0a56da3a957a113ea1bfedd78c7e6">rte_hash_lookup_with_hash</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const void *key, <a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a> sig)</td></tr>
<tr class="separator:a8bf0a56da3a957a113ea1bfedd78c7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ac52308164e81c1b5cc082c3b59970"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a42ac52308164e81c1b5cc082c3b59970">rte_hash_hash</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const void *key)</td></tr>
<tr class="separator:a42ac52308164e81c1b5cc082c3b59970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420dedbd249c73bbb94a98e10a87b088"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__hash_8h.html#a420dedbd249c73bbb94a98e10a87b088">rte_hash_lookup_bulk</a> (const struct <a class="el" href="structrte__hash.html">rte_hash</a> *h, const void **keys, uint32_t num_keys, int32_t *positions)</td></tr>
<tr class="separator:a420dedbd249c73bbb94a98e10a87b088"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE Hash Table </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="af6aad50c1c5af42b9fe1210bb7edb2e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_HASH_BUCKET_ENTRIES_MAX&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum bucket size that can be created. </p>

</div>
</div>
<a class="anchor" id="a080e28e97cdd08dddfee7fc49084c0f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_HASH_ENTRIES_MAX&#160;&#160;&#160;(1 &lt;&lt; 26)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum size of hash table that can be created. </p>

</div>
</div>
<a class="anchor" id="adc9a7a326415377f904b9e323abd5dbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_HASH_KEY_LENGTH_MAX&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum length of key that can be used. </p>

</div>
</div>
<a class="anchor" id="a40d9cbb1b31cf0a18427128378bc94ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_HASH_LOOKUP_BULK_MAX&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max number of keys that can be searched for using rte_hash_lookup_multi. </p>

</div>
</div>
<a class="anchor" id="a6f2eca61b3180fccd47b5170fa115d48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_HASH_NAMESIZE&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max number of characters in hash name. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ab9cf833d6d86f042b9ac01ae2e5b998f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Signature of key that is stored internally. </p>

</div>
</div>
<a class="anchor" id="a1b12fdd40a9aa9aa254d45b052e57350"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t(* rte_hash_function) (const void *key, uint32_t key_len, uint32_t init_val)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of function that can be used for calculating the hash value. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a0247f58baa6cbf614e5b729ff0baf27e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rte_hash_add_key </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a key to an existing hash table. This operation is not multi-thread safe and should only be called from one thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to add the key to. </td></tr>
    <tr><td class="paramname">key</td><td>Key to add to the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOSPC if there is no space in the hash for this key.</li>
<li>A positive value that can be used by the caller as an offset into an array of user data. This value is unique for this key. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aaa426cfe49f1b6750cf35e932bb55067"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rte_hash_add_key_with_hash </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a>&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a key to an existing hash table. This operation is not multi-thread safe and should only be called from one thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to add the key to. </td></tr>
    <tr><td class="paramname">key</td><td>Key to add to the hash table. </td></tr>
    <tr><td class="paramname">sig</td><td>Hash value to add to the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOSPC if there is no space in the hash for this key.</li>
<li>A positive value that can be used by the caller as an offset into an array of user data. This value is unique for this key. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5afbd2564f738149a241bc22b2428612"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__hash.html">rte_hash</a>* rte_hash_create </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash__parameters.html">rte_hash_parameters</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new hash table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>Parameters used to create and initialise the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to hash table structure that is used in future hash table operations, or NULL on error, with error code set in rte_errno. Possible rte_errno errors include:<ul>
<li>E_RTE_NO_CONFIG - function could not get pointer to <a class="el" href="structrte__config.html">rte_config</a> structure</li>
<li>E_RTE_SECONDARY - function was called from a secondary process instance</li>
<li>E_RTE_NO_TAILQ - no tailq list could be got for the hash table list</li>
<li>ENOENT - missing entry</li>
<li>EINVAL - invalid parameter passed to function</li>
<li>ENOSPC - the maximum number of memzones has already been allocated</li>
<li>EEXIST - a memzone with the same name already exists</li>
<li>ENOMEM - no appropriate memory area found in which to create memzone </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aaa125f9c9f57ea5fdf2752bcb506a058"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rte_hash_del_key </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a key from an existing hash table. This operation is not multi-thread safe and should only be called from one thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to remove the key from. </td></tr>
    <tr><td class="paramname">key</td><td>Key to remove from the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOENT if the key is not found.</li>
<li>A positive value that can be used by the caller as an offset into an array of user data. This value is unique for this key, and is the same value that was returned when the key was added. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0da9abc1a395e6891d5f5d0f2ac69cf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rte_hash_del_key_with_hash </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a>&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a key from an existing hash table. This operation is not multi-thread safe and should only be called from one thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to remove the key from. </td></tr>
    <tr><td class="paramname">key</td><td>Key to remove from the hash table. </td></tr>
    <tr><td class="paramname">sig</td><td>Hash value to remove from the hash table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOENT if the key is not found.</li>
<li>A positive value that can be used by the caller as an offset into an array of user data. This value is unique for this key, and is the same value that was returned when the key was added. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a04c3876597e47c045c945d78e0e1d332"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__hash.html">rte_hash</a>* rte_hash_find_existing </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find an existing hash table object and return a pointer to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the hash table as passed to <a class="el" href="rte__hash_8h.html#a5afbd2564f738149a241bc22b2428612">rte_hash_create()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to hash table or NULL if object not found with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>ENOENT - value not available for return </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a2b82800460ad6918b822db30d1c21f77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_hash_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>De-allocate all memory used by hash table. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42ac52308164e81c1b5cc082c3b59970"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a> rte_hash_hash </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calc a hash value by key. This operation is not multi-process safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to look in. </td></tr>
    <tr><td class="paramname">key</td><td>Key to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>hash value </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a62ff0b837d39bbff00863feabf15e224"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rte_hash_lookup </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a key in the hash table. This operation is multi-thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to look in. </td></tr>
    <tr><td class="paramname">key</td><td>Key to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOENT if the key is not found.</li>
<li>A positive value that can be used by the caller as an offset into an array of user data. This value is unique for this key, and is the same value that was returned when the key was added. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a420dedbd249c73bbb94a98e10a87b088"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_hash_lookup_bulk </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>positions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find multiple keys in the hash table. This operation is multi-thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to look in. </td></tr>
    <tr><td class="paramname">keys</td><td>A pointer to a list of keys to look for. </td></tr>
    <tr><td class="paramname">num_keys</td><td>How many keys are in the keys list (less than RTE_HASH_LOOKUP_BULK_MAX). </td></tr>
    <tr><td class="paramname">positions</td><td>Output containing a list of values, corresponding to the list of keys that can be used by the caller as an offset into an array of user data. These values are unique for each key, and are the same values that were returned when each key was added. If a key in the list was not found, then -ENOENT will be the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-EINVAL if there's an error, otherwise 0. </dd></dl>

</div>
</div>
<a class="anchor" id="a8bf0a56da3a957a113ea1bfedd78c7e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t rte_hash_lookup_with_hash </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__hash.html">rte_hash</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__hash_8h.html#ab9cf833d6d86f042b9ac01ae2e5b998f">hash_sig_t</a>&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a key in the hash table. This operation is multi-thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>Hash table to look in. </td></tr>
    <tr><td class="paramname">key</td><td>Key to find. </td></tr>
    <tr><td class="paramname">sig</td><td>Hash value to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-EINVAL if the parameters are invalid.</li>
<li>-ENOENT if the key is not found.</li>
<li>A positive value that can be used by the caller as an offset into an array of user data. This value is unique for this key, and is the same value that was returned when the key was added. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
