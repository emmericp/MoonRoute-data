<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>DPDK: lib/librte_acl/rte_acl.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_fcaecf9e47d3074427ceb27ca105ed74.html">lib</a></li><li class="navelem"><a class="el" href="dir_1183b37a9e77ab541d37399b22a483c3.html">librte_acl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_acl.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="rte__acl__osdep_8h.html">rte_acl_osdep.h</a>&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__acl__field__def.html">rte_acl_field_def</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__acl__config.html">rte_acl_config</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__acl__field.html">rte_acl_field</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__acl__rule__data.html">rte_acl_rule_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__acl__param.html">rte_acl_param</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__acl__ipv4vlan__rule.html">rte_acl_ipv4vlan_rule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae5ab707258c6c9fbe28832902cbacf1c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__acl_8h.html#ae5ab707258c6c9fbe28832902cbacf1c">RTE_ACL_RULE_DEF</a>(name,  fld_num)</td></tr>
<tr class="separator:ae5ab707258c6c9fbe28832902cbacf1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf1f22817805ac2fda9fee671c66d83"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__acl_8h.html#aedf1f22817805ac2fda9fee671c66d83">RTE_ACL_NAMESIZE</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:aedf1f22817805ac2fda9fee671c66d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44228dc215831fbb96f0262759bd9ed9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__acl_8h.html#a44228dc215831fbb96f0262759bd9ed9">RTE_ACL_IPV4VLAN_RULE_SZ</a>&#160;&#160;&#160;RTE_ACL_RULE_SZ(RTE_ACL_IPV4VLAN_NUM_FIELDS)</td></tr>
<tr class="separator:a44228dc215831fbb96f0262759bd9ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a86a25ccd8348bf492656f3a10d77ed7b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__acl_8h.html#a86a25ccd8348bf492656f3a10d77ed7b">rte_acl_classify_alg</a> { , <a class="el" href="rte__acl_8h.html#a86a25ccd8348bf492656f3a10d77ed7ba9847e79fbf50793cd926f346c20a2417">RTE_ACL_CLASSIFY_SCALAR</a> = 1, 
<a class="el" href="rte__acl_8h.html#a86a25ccd8348bf492656f3a10d77ed7ba3a65a7a7012ee0f49d7815e79fa9b39f">RTE_ACL_CLASSIFY_SSE</a> = 2
 }</td></tr>
<tr class="separator:a86a25ccd8348bf492656f3a10d77ed7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5c98fcc1211af2b80116dd6e0a035d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:abc5c98fcc1211af2b80116dd6e0a035d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af230a8bd56f72b86af5e99375fb75313"><td class="memItemLeft" align="right" valign="top">struct rte_acl_ctx *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__acl_8h.html#af230a8bd56f72b86af5e99375fb75313">rte_acl_create</a> (const struct <a class="el" href="structrte__acl__param.html">rte_acl_param</a> *param)</td></tr>
<tr class="separator:af230a8bd56f72b86af5e99375fb75313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9869046e2c9ddb01b8d8ff0d0a39db3"><td class="memItemLeft" align="right" valign="top">struct rte_acl_ctx *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__acl_8h.html#ad9869046e2c9ddb01b8d8ff0d0a39db3">rte_acl_find_existing</a> (const char *name)</td></tr>
<tr class="separator:ad9869046e2c9ddb01b8d8ff0d0a39db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b48b27ddc2bdbda007bb7411a9b217"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__acl_8h.html#a97b48b27ddc2bdbda007bb7411a9b217">rte_acl_free</a> (struct rte_acl_ctx *ctx)</td></tr>
<tr class="separator:a97b48b27ddc2bdbda007bb7411a9b217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c0f9c8f982c2c41896e09f435b4f23"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__acl_8h.html#a54c0f9c8f982c2c41896e09f435b4f23">rte_acl_add_rules</a> (struct rte_acl_ctx *ctx, const struct rte_acl_rule *rules, uint32_t num)</td></tr>
<tr class="separator:a54c0f9c8f982c2c41896e09f435b4f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67100817506dc9ae1e1236f464dd034b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__acl_8h.html#a67100817506dc9ae1e1236f464dd034b">rte_acl_reset_rules</a> (struct rte_acl_ctx *ctx)</td></tr>
<tr class="separator:a67100817506dc9ae1e1236f464dd034b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb4409451df7950758380aee7c43479"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__acl_8h.html#aecb4409451df7950758380aee7c43479">rte_acl_build</a> (struct rte_acl_ctx *ctx, const struct <a class="el" href="structrte__acl__config.html">rte_acl_config</a> *cfg)</td></tr>
<tr class="separator:aecb4409451df7950758380aee7c43479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5754c1340a2f9d08c7f656d6e2714c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__acl_8h.html#a5c5754c1340a2f9d08c7f656d6e2714c">rte_acl_reset</a> (struct rte_acl_ctx *ctx)</td></tr>
<tr class="separator:a5c5754c1340a2f9d08c7f656d6e2714c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c75dcc2bddb3ce02c171f20d2f5854"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__acl_8h.html#a97c75dcc2bddb3ce02c171f20d2f5854">rte_acl_classify</a> (const struct rte_acl_ctx *ctx, const uint8_t **data, uint32_t *results, uint32_t num, uint32_t categories)</td></tr>
<tr class="separator:a97c75dcc2bddb3ce02c171f20d2f5854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88da04a8f354cbc13dcadce04ecb6590"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__acl_8h.html#a88da04a8f354cbc13dcadce04ecb6590">rte_acl_classify_alg</a> (const struct rte_acl_ctx *ctx, const uint8_t **data, uint32_t *results, uint32_t num, uint32_t categories, enum <a class="el" href="rte__acl_8h.html#a86a25ccd8348bf492656f3a10d77ed7b">rte_acl_classify_alg</a> alg)</td></tr>
<tr class="separator:a88da04a8f354cbc13dcadce04ecb6590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b5b259f43c5eb3c55e13e548b4998c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__acl_8h.html#a33b5b259f43c5eb3c55e13e548b4998c">rte_acl_dump</a> (const struct rte_acl_ctx *ctx)</td></tr>
<tr class="separator:a33b5b259f43c5eb3c55e13e548b4998c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108a4af075d46a0cd626d6ba154be541"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__acl_8h.html#a108a4af075d46a0cd626d6ba154be541">rte_acl_list_dump</a> (void)</td></tr>
<tr class="separator:a108a4af075d46a0cd626d6ba154be541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e272a5aec104c31050482f19f1acf7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__acl_8h.html#aa6e272a5aec104c31050482f19f1acf7">rte_acl_ipv4vlan_add_rules</a> (struct rte_acl_ctx *ctx, const struct <a class="el" href="structrte__acl__ipv4vlan__rule.html">rte_acl_ipv4vlan_rule</a> *rules, uint32_t num)</td></tr>
<tr class="separator:aa6e272a5aec104c31050482f19f1acf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c55f7fc7066f487bf133a95dde12c24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__acl_8h.html#a9c55f7fc7066f487bf133a95dde12c24">rte_acl_ipv4vlan_build</a> (struct rte_acl_ctx *ctx, const uint32_t layout[RTE_ACL_IPV4VLAN_NUM], uint32_t num_categories)</td></tr>
<tr class="separator:a9c55f7fc7066f487bf133a95dde12c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE Classifier. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a44228dc215831fbb96f0262759bd9ed9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ACL_IPV4VLAN_RULE_SZ&#160;&#160;&#160;RTE_ACL_RULE_SZ(RTE_ACL_IPV4VLAN_NUM_FIELDS)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro to define rule size for <a class="el" href="structrte__acl__ipv4vlan__rule.html">rte_acl_ipv4vlan_rule</a>. </p>

</div>
</div>
<a class="anchor" id="aedf1f22817805ac2fda9fee671c66d83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ACL_NAMESIZE&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max number of characters in name. </p>

</div>
</div>
<a class="anchor" id="ae5ab707258c6c9fbe28832902cbacf1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_ACL_RULE_DEF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">fld_num&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">struct </span>name {\</div>
<div class="line">    struct <a class="code" href="structrte__acl__rule__data.html">rte_acl_rule_data</a> data;               \</div>
<div class="line">    struct <a class="code" href="structrte__acl__field.html">rte_acl_field</a> field[fld_num];         \</div>
<div class="line">}</div>
<div class="ttc" id="structrte__acl__field_html"><div class="ttname"><a href="structrte__acl__field.html">rte_acl_field</a></div><div class="ttdef"><b>Definition:</b> rte_acl.h:102</div></div>
<div class="ttc" id="structrte__acl__rule__data_html"><div class="ttname"><a href="structrte__acl__rule__data.html">rte_acl_rule_data</a></div><div class="ttdef"><b>Definition:</b> rte_acl.h:126</div></div>
</div><!-- fragment --><p>Defines single ACL rule. data - miscellaneous data for the rule. field[] - value and mask or range for each field. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="abc5c98fcc1211af2b80116dd6e0a035d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies fields layout inside rte_acl_rule for <a class="el" href="structrte__acl__ipv4vlan__rule.html">rte_acl_ipv4vlan_rule</a>. </p>

</div>
</div>
<a class="anchor" id="a86a25ccd8348bf492656f3a10d77ed7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__acl_8h.html#a86a25ccd8348bf492656f3a10d77ed7b">rte_acl_classify_alg</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Avaialble implementations of ACL classify. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a86a25ccd8348bf492656f3a10d77ed7ba9847e79fbf50793cd926f346c20a2417"></a>RTE_ACL_CLASSIFY_SCALAR&#160;</td><td class="fielddoc">
<p>generic implementation. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a86a25ccd8348bf492656f3a10d77ed7ba3a65a7a7012ee0f49d7815e79fa9b39f"></a>RTE_ACL_CLASSIFY_SSE&#160;</td><td class="fielddoc">
<p>requries SSE4.1 support. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a54c0f9c8f982c2c41896e09f435b4f23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_acl_add_rules </td>
          <td>(</td>
          <td class="paramtype">struct rte_acl_ctx *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct rte_acl_rule *&#160;</td>
          <td class="paramname"><em>rules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add rules to an existing ACL context. This function is not multi-thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>ACL context to add patterns to. </td></tr>
    <tr><td class="paramname">rules</td><td>Array of rules to add to the ACL context. Note that all fields in rte_acl_rule structures are expected to be in host byte order. Each rule expected to be in the same format and not exceed size specified at ACL context creation time. </td></tr>
    <tr><td class="paramname">num</td><td>Number of elements in the input array of rules. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-ENOMEM if there is no space in the ACL context for these rules.</li>
<li>-EINVAL if the parameters are invalid.</li>
<li>Zero if operation completed successfully. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aecb4409451df7950758380aee7c43479"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_acl_build </td>
          <td>(</td>
          <td class="paramtype">struct rte_acl_ctx *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__acl__config.html">rte_acl_config</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Analyze set of rules and build required internal run-time structures. This function is not multi-thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>ACL context to build. </td></tr>
    <tr><td class="paramname">cfg</td><td>Pointer to struct <a class="el" href="structrte__acl__config.html">rte_acl_config</a> - defines build parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-ENOMEM if couldn't allocate enough memory.</li>
<li>-EINVAL if the parameters are invalid.</li>
<li>Negative error code if operation failed.</li>
<li>Zero if operation completed successfully. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a97c75dcc2bddb3ce02c171f20d2f5854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_acl_classify </td>
          <td>(</td>
          <td class="paramtype">const struct rte_acl_ctx *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>categories</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform search for a matching ACL rule for each input data buffer. Each input data buffer can have up to <em>categories</em> matches. That implies that results array should be big enough to hold (categories * num) elements. Also categories parameter should be either one or multiple of RTE_ACL_RESULTS_MULTIPLIER and can't be bigger than RTE_ACL_MAX_CATEGORIES. If more than one rule is applicable for given input buffer and given category, then rule with highest priority will be returned as a match. Note, that it is a caller's responsibility to ensure that input parameters are valid and point to correct memory locations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>ACL context to search with. </td></tr>
    <tr><td class="paramname">data</td><td>Array of pointers to input data buffers to perform search. Note that all fields in input data buffers supposed to be in network byte order (MSB). </td></tr>
    <tr><td class="paramname">results</td><td>Array of search results, <em>categories</em> results per each input data buffer. </td></tr>
    <tr><td class="paramname">num</td><td>Number of elements in the input data buffers array. </td></tr>
    <tr><td class="paramname">categories</td><td>Number of maximum possible matches for each input buffer, one possible match per category. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on successful completion. -EINVAL for incorrect arguments. </dd></dl>

</div>
</div>
<a class="anchor" id="a88da04a8f354cbc13dcadce04ecb6590"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="rte__acl_8h.html#a86a25ccd8348bf492656f3a10d77ed7b">rte_acl_classify_alg</a> </td>
          <td>(</td>
          <td class="paramtype">const struct rte_acl_ctx *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>categories</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__acl_8h.html#a86a25ccd8348bf492656f3a10d77ed7b">rte_acl_classify_alg</a>&#160;</td>
          <td class="paramname"><em>alg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform search using specified algorithm for a matching ACL rule for each input data buffer. Each input data buffer can have up to <em>categories</em> matches. That implies that results array should be big enough to hold (categories * num) elements. Also categories parameter should be either one or multiple of RTE_ACL_RESULTS_MULTIPLIER and can't be bigger than RTE_ACL_MAX_CATEGORIES. If more than one rule is applicable for given input buffer and given category, then rule with highest priority will be returned as a match. Note, that it is a caller's responsibility to ensure that input parameters are valid and point to correct memory locations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>ACL context to search with. </td></tr>
    <tr><td class="paramname">data</td><td>Array of pointers to input data buffers to perform search. Note that all fields in input data buffers supposed to be in network byte order (MSB). </td></tr>
    <tr><td class="paramname">results</td><td>Array of search results, <em>categories</em> results per each input data buffer. </td></tr>
    <tr><td class="paramname">num</td><td>Number of elements in the input data buffers array. </td></tr>
    <tr><td class="paramname">categories</td><td>Number of maximum possible matches for each input buffer, one possible match per category. </td></tr>
    <tr><td class="paramname">alg</td><td>Algorithm to be used for the search. It is the caller responibility to ensure that the value refers to the existing algorithm, and that it could be run on the given CPU. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on successful completion. -EINVAL for incorrect arguments. </dd></dl>

</div>
</div>
<a class="anchor" id="af230a8bd56f72b86af5e99375fb75313"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rte_acl_ctx* rte_acl_create </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__acl__param.html">rte_acl_param</a> *&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new ACL context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>Parameters used to create and initialise the ACL context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to ACL context structure that is used in future ACL operations, or NULL on error, with error code set in rte_errno. Possible rte_errno errors include:<ul>
<li>E_RTE_NO_TAILQ - no tailq list could be got for the ACL context list</li>
<li>EINVAL - invalid parameter passed to function </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a33b5b259f43c5eb3c55e13e548b4998c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_acl_dump </td>
          <td>(</td>
          <td class="paramtype">const struct rte_acl_ctx *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump an ACL context structure to the console.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>ACL context to dump. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9869046e2c9ddb01b8d8ff0d0a39db3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rte_acl_ctx* rte_acl_find_existing </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find an existing ACL context object and return a pointer to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the ACL context as passed to <a class="el" href="rte__acl_8h.html#af230a8bd56f72b86af5e99375fb75313">rte_acl_create()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to ACL context or NULL if object not found with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>ENOENT - value not available for return </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a97b48b27ddc2bdbda007bb7411a9b217"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_acl_free </td>
          <td>(</td>
          <td class="paramtype">struct rte_acl_ctx *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>De-allocate all memory used by ACL context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>ACL context to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6e272a5aec104c31050482f19f1acf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_acl_ipv4vlan_add_rules </td>
          <td>(</td>
          <td class="paramtype">struct rte_acl_ctx *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__acl__ipv4vlan__rule.html">rte_acl_ipv4vlan_rule</a> *&#160;</td>
          <td class="paramname"><em>rules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add ipv4vlan rules to an existing ACL context. This function is not multi-thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>ACL context to add patterns to. </td></tr>
    <tr><td class="paramname">rules</td><td>Array of rules to add to the ACL context. Note that all fields in <a class="el" href="structrte__acl__ipv4vlan__rule.html">rte_acl_ipv4vlan_rule</a> structures are expected to be in host byte order. </td></tr>
    <tr><td class="paramname">num</td><td>Number of elements in the input array of rules. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-ENOMEM if there is no space in the ACL context for these rules.</li>
<li>-EINVAL if the parameters are invalid.</li>
<li>Zero if operation completed successfully. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a9c55f7fc7066f487bf133a95dde12c24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_acl_ipv4vlan_build </td>
          <td>(</td>
          <td class="paramtype">struct rte_acl_ctx *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>layout</em>[RTE_ACL_IPV4VLAN_NUM], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>num_categories</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Analyze set of ipv4vlan rules and build required internal run-time structures. This function is not multi-thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>ACL context to build. </td></tr>
    <tr><td class="paramname">layout</td><td>Layout of input data to search through. </td></tr>
    <tr><td class="paramname">num_categories</td><td>Maximum number of categories to use in that build. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>-ENOMEM if couldn't allocate enough memory.</li>
<li>-EINVAL if the parameters are invalid.</li>
<li>Negative error code if operation failed.</li>
<li>Zero if operation completed successfully. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a108a4af075d46a0cd626d6ba154be541"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_acl_list_dump </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump all ACL context structures to the console. </p>

</div>
</div>
<a class="anchor" id="a5c5754c1340a2f9d08c7f656d6e2714c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_acl_reset </td>
          <td>(</td>
          <td class="paramtype">struct rte_acl_ctx *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete all rules from the ACL context and destroy all internal run-time structures. This function is not multi-thread safe.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>ACL context to reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67100817506dc9ae1e1236f464dd034b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_acl_reset_rules </td>
          <td>(</td>
          <td class="paramtype">struct rte_acl_ctx *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete all rules from the ACL context. This function is not multi-thread safe. Note that internal run-time structures are not affected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>ACL context to delete rules from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
