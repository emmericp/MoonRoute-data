<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>DPDK: lib/librte_ether/rte_ethdev.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_fcaecf9e47d3074427ceb27ca105ed74.html">lib</a></li><li class="navelem"><a class="el" href="dir_b1efe09cd9b3322408fa95d8f27be0b8.html">librte_ether</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_ethdev.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__log_8h.html">rte_log.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__interrupts_8h.html">rte_interrupts.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__pci_8h.html">rte_pci.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__mbuf_8h.html">rte_mbuf.h</a>&gt;</code><br />
<code>#include &quot;<a class="el" href="rte__ether_8h.html">rte_ether.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__stats.html">rte_eth_stats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__link.html">rte_eth_link</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__thresh.html">rte_eth_thresh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__rxmode.html">rte_eth_rxmode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__rss__conf.html">rte_eth_rss_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__vlan__mirror.html">rte_eth_vlan_mirror</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__vmdq__mirror__conf.html">rte_eth_vmdq_mirror_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__rss__reta.html">rte_eth_rss_reta</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__vmdq__dcb__conf.html">rte_eth_vmdq_dcb_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__txmode.html">rte_eth_txmode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__rxconf.html">rte_eth_rxconf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__txconf.html">rte_eth_txconf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__fc__conf.html">rte_eth_fc_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__pfc__conf.html">rte_eth_pfc_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__fdir__conf.html">rte_fdir_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__fdir__filter.html">rte_fdir_filter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__fdir__masks.html">rte_fdir_masks</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__fdir.html">rte_eth_fdir</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__intr__conf.html">rte_intr_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__eth__conf.html">rte_eth_conf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__ethertype__filter.html">rte_ethertype_filter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__syn__filter.html">rte_syn_filter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__2tuple__filter.html">rte_2tuple_filter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__flex__filter.html">rte_flex_filter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__5tuple__filter.html">rte_5tuple_filter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ade7de72f6c0f8102d01a0b3438856900"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ade7de72f6c0f8102d01a0b3438856900">ETH_LINK_SPEED_AUTONEG</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ade7de72f6c0f8102d01a0b3438856900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e7915541f4d165f5a7ea6e69a7a239"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a10e7915541f4d165f5a7ea6e69a7a239">ETH_LINK_SPEED_10</a>&#160;&#160;&#160;10</td></tr>
<tr class="separator:a10e7915541f4d165f5a7ea6e69a7a239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea145ff8ac2ec81ef9e66703d5c90360"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aea145ff8ac2ec81ef9e66703d5c90360">ETH_LINK_SPEED_100</a>&#160;&#160;&#160;100</td></tr>
<tr class="separator:aea145ff8ac2ec81ef9e66703d5c90360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b0fcfcc5873cad9e15b5686b9e6453"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ab8b0fcfcc5873cad9e15b5686b9e6453">ETH_LINK_SPEED_1000</a>&#160;&#160;&#160;1000</td></tr>
<tr class="separator:ab8b0fcfcc5873cad9e15b5686b9e6453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36b5d80e47efd37116b2ef6c0aa0ace"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af36b5d80e47efd37116b2ef6c0aa0ace">ETH_LINK_SPEED_10000</a>&#160;&#160;&#160;10000</td></tr>
<tr class="separator:af36b5d80e47efd37116b2ef6c0aa0ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a1fe61e5db2ae7951532f45f903fb5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac4a1fe61e5db2ae7951532f45f903fb5">ETH_LINK_SPEED_10G</a>&#160;&#160;&#160;10000</td></tr>
<tr class="separator:ac4a1fe61e5db2ae7951532f45f903fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293f557c186179155f0eef5c8e42c669"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a293f557c186179155f0eef5c8e42c669">ETH_LINK_SPEED_20G</a>&#160;&#160;&#160;20000</td></tr>
<tr class="separator:a293f557c186179155f0eef5c8e42c669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb76ba55e97f704ca58e5b20b689d050"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aeb76ba55e97f704ca58e5b20b689d050">ETH_LINK_SPEED_40G</a>&#160;&#160;&#160;40000</td></tr>
<tr class="separator:aeb76ba55e97f704ca58e5b20b689d050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e049bfb5699883d548628263f16ad7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ae7e049bfb5699883d548628263f16ad7">ETH_LINK_AUTONEG_DUPLEX</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ae7e049bfb5699883d548628263f16ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c07663fb6353f36d0be00c6744f3f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a56c07663fb6353f36d0be00c6744f3f0">ETH_LINK_HALF_DUPLEX</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a56c07663fb6353f36d0be00c6744f3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042c83951613bf2db5d3056b967041d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a042c83951613bf2db5d3056b967041d6">ETH_LINK_FULL_DUPLEX</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a042c83951613bf2db5d3056b967041d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a06d7bfbfc1ac0c6623716b2ba5a829"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a8a06d7bfbfc1ac0c6623716b2ba5a829">ETH_RSS</a>&#160;&#160;&#160;<a class="el" href="rte__ethdev_8h.html#a586b8e86131b4ec0ccaf464e847ccf3eaa06694239b7ecf1efa3c9243b9e7b4c0">ETH_MQ_RX_RSS</a></td></tr>
<tr class="separator:a8a06d7bfbfc1ac0c6623716b2ba5a829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada4dc197e51fc9ddd45c3f80c3cd6fe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aada4dc197e51fc9ddd45c3f80c3cd6fe">ETH_DCB_NONE</a>&#160;&#160;&#160;<a class="el" href="rte__ethdev_8h.html#a4834f572f4dd4e46d81ad09b7d5fffd5aada568551470d5f419cd2f3d6b6bfedc">ETH_MQ_TX_NONE</a></td></tr>
<tr class="separator:aada4dc197e51fc9ddd45c3f80c3cd6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30da5c1c2145999f6b8e0190d1c3e95"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac30da5c1c2145999f6b8e0190d1c3e95">ETH_RSS_UDP</a></td></tr>
<tr class="separator:ac30da5c1c2145999f6b8e0190d1c3e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606a6b69adcfa6dd6c3fa4a31688bd4c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a606a6b69adcfa6dd6c3fa4a31688bd4c">ETH_VMDQ_MAX_VLAN_FILTERS</a>&#160;&#160;&#160;64</td></tr>
<tr class="separator:a606a6b69adcfa6dd6c3fa4a31688bd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825a952bfb398214537ed14e60af758d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a825a952bfb398214537ed14e60af758d">ETH_DCB_NUM_USER_PRIORITIES</a>&#160;&#160;&#160;8</td></tr>
<tr class="separator:a825a952bfb398214537ed14e60af758d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a68aadc20116d23d2408e4595d9d4a6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a4a68aadc20116d23d2408e4595d9d4a6">ETH_VMDQ_DCB_NUM_QUEUES</a>&#160;&#160;&#160;128</td></tr>
<tr class="separator:a4a68aadc20116d23d2408e4595d9d4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96f7b85443dc9c8553176315a2e1b26"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac96f7b85443dc9c8553176315a2e1b26">ETH_DCB_NUM_QUEUES</a>&#160;&#160;&#160;128</td></tr>
<tr class="separator:ac96f7b85443dc9c8553176315a2e1b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c3436701eb68875ba6404695616554"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a39c3436701eb68875ba6404695616554">ETH_DCB_PG_SUPPORT</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="separator:a39c3436701eb68875ba6404695616554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a80c71b5fcc67a53c2efe1692374430"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a3a80c71b5fcc67a53c2efe1692374430">ETH_DCB_PFC_SUPPORT</a>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="separator:a3a80c71b5fcc67a53c2efe1692374430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1625e8d55cc3138ac05eeed1b65cfd8f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a1625e8d55cc3138ac05eeed1b65cfd8f">ETH_VLAN_STRIP_OFFLOAD</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="separator:a1625e8d55cc3138ac05eeed1b65cfd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19dad4459c4351837eeebc156abcc964"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a19dad4459c4351837eeebc156abcc964">ETH_VLAN_FILTER_OFFLOAD</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="separator:a19dad4459c4351837eeebc156abcc964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75707b9e228ba0735d74acb20b359d30"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a75707b9e228ba0735d74acb20b359d30">ETH_VLAN_EXTEND_OFFLOAD</a>&#160;&#160;&#160;0x0004</td></tr>
<tr class="separator:a75707b9e228ba0735d74acb20b359d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40188f42e8bac5e53e05b74f384cf8f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a40188f42e8bac5e53e05b74f384cf8f7">ETH_VLAN_STRIP_MASK</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="separator:a40188f42e8bac5e53e05b74f384cf8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8d27c456f1d17c9ec96326a602a0bc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aee8d27c456f1d17c9ec96326a602a0bc">ETH_VLAN_FILTER_MASK</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="separator:aee8d27c456f1d17c9ec96326a602a0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cbca7a78bd10b5223483283fc3467b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af9cbca7a78bd10b5223483283fc3467b">ETH_VLAN_EXTEND_MASK</a>&#160;&#160;&#160;0x0004</td></tr>
<tr class="separator:af9cbca7a78bd10b5223483283fc3467b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3fccc96c0353c7ba4df17c5af3cec1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aca3fccc96c0353c7ba4df17c5af3cec1">ETH_VLAN_ID_MAX</a>&#160;&#160;&#160;0x0FFF</td></tr>
<tr class="separator:aca3fccc96c0353c7ba4df17c5af3cec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216f71b2f5bd80c770157fc6f24b6997"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a216f71b2f5bd80c770157fc6f24b6997">ETH_NUM_RECEIVE_MAC_ADDR</a>&#160;&#160;&#160;128</td></tr>
<tr class="separator:a216f71b2f5bd80c770157fc6f24b6997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86c9ef9ed563598fa81af6bc93f34a8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ae86c9ef9ed563598fa81af6bc93f34a8">ETH_VMDQ_NUM_UC_HASH_ARRAY</a>&#160;&#160;&#160;128</td></tr>
<tr class="separator:ae86c9ef9ed563598fa81af6bc93f34a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12dfb4c0db1629988f157a75c84debb3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a12dfb4c0db1629988f157a75c84debb3">ETH_VMDQ_ACCEPT_UNTAG</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="separator:a12dfb4c0db1629988f157a75c84debb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eaee466b4e51ad3dcb406305dbadf4f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a6eaee466b4e51ad3dcb406305dbadf4f">ETH_VMDQ_ACCEPT_HASH_MC</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="separator:a6eaee466b4e51ad3dcb406305dbadf4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59aeaf95ad1984ce76e298ee1dd8451"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aa59aeaf95ad1984ce76e298ee1dd8451">ETH_VMDQ_ACCEPT_HASH_UC</a>&#160;&#160;&#160;0x0004</td></tr>
<tr class="separator:aa59aeaf95ad1984ce76e298ee1dd8451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb1059587ee40589f8d9da60107e740"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a5cb1059587ee40589f8d9da60107e740">ETH_VMDQ_ACCEPT_BROADCAST</a>&#160;&#160;&#160;0x0008</td></tr>
<tr class="separator:a5cb1059587ee40589f8d9da60107e740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0109eb1974972c4fc0f964bc4de3b1a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac0109eb1974972c4fc0f964bc4de3b1a">ETH_VMDQ_ACCEPT_MULTICAST</a>&#160;&#160;&#160;0x0010</td></tr>
<tr class="separator:ac0109eb1974972c4fc0f964bc4de3b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfb476ec43e33fb0146b62095a3a191"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#afbfb476ec43e33fb0146b62095a3a191">ETH_VMDQ_NUM_MIRROR_RULE</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:afbfb476ec43e33fb0146b62095a3a191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e03bee5f8806d7abee5304cd709544"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ab0e03bee5f8806d7abee5304cd709544">ETH_VMDQ_POOL_MIRROR</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="separator:ab0e03bee5f8806d7abee5304cd709544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb13991e558a7086a5cee1bac603aec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a5cb13991e558a7086a5cee1bac603aec">ETH_VMDQ_UPLINK_MIRROR</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="separator:a5cb13991e558a7086a5cee1bac603aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fb0bd604952e8ec9ab37495ecd508d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a30fb0bd604952e8ec9ab37495ecd508d">ETH_VMDQ_DOWNLIN_MIRROR</a>&#160;&#160;&#160;0x0004</td></tr>
<tr class="separator:a30fb0bd604952e8ec9ab37495ecd508d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af251d6a0938ea060afbb80f427be82c4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af251d6a0938ea060afbb80f427be82c4">ETH_VMDQ_VLAN_MIRROR</a>&#160;&#160;&#160;0x0008</td></tr>
<tr class="separator:af251d6a0938ea060afbb80f427be82c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4902a1d01782ecc690203f9e9df25ee9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a4902a1d01782ecc690203f9e9df25ee9">ETH_TXQ_FLAGS_NOMULTSEGS</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="separator:a4902a1d01782ecc690203f9e9df25ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d955036397d06a5cdd04a9206418221"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a2d955036397d06a5cdd04a9206418221">ETH_TXQ_FLAGS_NOREFCOUNT</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="separator:a2d955036397d06a5cdd04a9206418221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c92e990d49639224f73c538aa7f93e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac6c92e990d49639224f73c538aa7f93e">ETH_TXQ_FLAGS_NOMULTMEMP</a>&#160;&#160;&#160;0x0004</td></tr>
<tr class="separator:ac6c92e990d49639224f73c538aa7f93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b377dce04cd001079a35f5b7746276"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ae8b377dce04cd001079a35f5b7746276">ETH_TXQ_FLAGS_NOVLANOFFL</a>&#160;&#160;&#160;0x0100</td></tr>
<tr class="separator:ae8b377dce04cd001079a35f5b7746276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec79bc280fce5e9cd39c02aee4eeebf9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aec79bc280fce5e9cd39c02aee4eeebf9">ETH_TXQ_FLAGS_NOXSUMSCTP</a>&#160;&#160;&#160;0x0200</td></tr>
<tr class="separator:aec79bc280fce5e9cd39c02aee4eeebf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1389985a56456cc0996af7fddeba10"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a5d1389985a56456cc0996af7fddeba10">ETH_TXQ_FLAGS_NOXSUMUDP</a>&#160;&#160;&#160;0x0400</td></tr>
<tr class="separator:a5d1389985a56456cc0996af7fddeba10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908a9cedf54de06cea43ec362a87fa1f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a908a9cedf54de06cea43ec362a87fa1f">ETH_TXQ_FLAGS_NOXSUMTCP</a>&#160;&#160;&#160;0x0800</td></tr>
<tr class="separator:a908a9cedf54de06cea43ec362a87fa1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544a5d22a4be048e8e5395fb965922ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a544a5d22a4be048e8e5395fb965922ed">DEV_RX_OFFLOAD_VLAN_STRIP</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="separator:a544a5d22a4be048e8e5395fb965922ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf0af5e228aeb2aaac39622cb6467ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#adaf0af5e228aeb2aaac39622cb6467ba">DEV_TX_OFFLOAD_VLAN_INSERT</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="separator:adaf0af5e228aeb2aaac39622cb6467ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab6765b205494199f0e9d8c058f94ed72"><td class="memItemLeft" align="right" valign="top">typedef uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ab6765b205494199f0e9d8c058f94ed72">eth_rx_queue_count_t</a>) (struct rte_eth_dev *dev, uint16_t rx_queue_id)</td></tr>
<tr class="separator:ab6765b205494199f0e9d8c058f94ed72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384677162d2f5804aed57efee7f439f9"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a384677162d2f5804aed57efee7f439f9">eth_rx_descriptor_done_t</a>) (void *rxq, uint16_t offset)</td></tr>
<tr class="separator:a384677162d2f5804aed57efee7f439f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f17da8528d43edd6810815530ee954"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a26f17da8528d43edd6810815530ee954">rte_eth_dev_cb_fn</a>) (uint8_t port_id, enum <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779d">rte_eth_event_type</a> event, void *cb_arg)</td></tr>
<tr class="separator:a26f17da8528d43edd6810815530ee954"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a586b8e86131b4ec0ccaf464e847ccf3e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a586b8e86131b4ec0ccaf464e847ccf3e">rte_eth_rx_mq_mode</a> { <br />
&#160;&#160;<a class="el" href="rte__ethdev_8h.html#a586b8e86131b4ec0ccaf464e847ccf3ea4600ff07419327deb9b8534bc66daf19">ETH_MQ_RX_NONE</a> = 0, 
<a class="el" href="rte__ethdev_8h.html#a586b8e86131b4ec0ccaf464e847ccf3eaa06694239b7ecf1efa3c9243b9e7b4c0">ETH_MQ_RX_RSS</a>, 
<a class="el" href="rte__ethdev_8h.html#a586b8e86131b4ec0ccaf464e847ccf3eaf85cf063ed90d84431c8b187d5a28e18">ETH_MQ_RX_DCB</a>, 
<a class="el" href="rte__ethdev_8h.html#a586b8e86131b4ec0ccaf464e847ccf3ea4874831bf9e11694ddcc277a63081525">ETH_MQ_RX_DCB_RSS</a>, 
<br />
&#160;&#160;<a class="el" href="rte__ethdev_8h.html#a586b8e86131b4ec0ccaf464e847ccf3ea66316d2ff53011a3209207734c124f3c">ETH_MQ_RX_VMDQ_ONLY</a>, 
<a class="el" href="rte__ethdev_8h.html#a586b8e86131b4ec0ccaf464e847ccf3ea2986c2bbbe392a5e9edade916d25ab5a">ETH_MQ_RX_VMDQ_RSS</a>, 
<a class="el" href="rte__ethdev_8h.html#a586b8e86131b4ec0ccaf464e847ccf3eae4fac92d0a259418226116609963a13d">ETH_MQ_RX_VMDQ_DCB</a>, 
<a class="el" href="rte__ethdev_8h.html#a586b8e86131b4ec0ccaf464e847ccf3eaed91aee4ae666352679780578589a121">ETH_MQ_RX_VMDQ_DCB_RSS</a>
<br />
 }</td></tr>
<tr class="separator:a586b8e86131b4ec0ccaf464e847ccf3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4834f572f4dd4e46d81ad09b7d5fffd5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a4834f572f4dd4e46d81ad09b7d5fffd5">rte_eth_tx_mq_mode</a> { <a class="el" href="rte__ethdev_8h.html#a4834f572f4dd4e46d81ad09b7d5fffd5aada568551470d5f419cd2f3d6b6bfedc">ETH_MQ_TX_NONE</a> = 0, 
<a class="el" href="rte__ethdev_8h.html#a4834f572f4dd4e46d81ad09b7d5fffd5ae53e78000f917e8d801a4cc9e354626d">ETH_MQ_TX_DCB</a>, 
<a class="el" href="rte__ethdev_8h.html#a4834f572f4dd4e46d81ad09b7d5fffd5a82109e803fcd709168e1ef8aa511dd97">ETH_MQ_TX_VMDQ_DCB</a>, 
<a class="el" href="rte__ethdev_8h.html#a4834f572f4dd4e46d81ad09b7d5fffd5a54923bde9b70a40e8455495d45747a9a">ETH_MQ_TX_VMDQ_ONLY</a>
 }</td></tr>
<tr class="separator:a4834f572f4dd4e46d81ad09b7d5fffd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb320893bc8887d4fa065488519edeeb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#afb320893bc8887d4fa065488519edeeb">rte_eth_nb_tcs</a> { <a class="el" href="rte__ethdev_8h.html#afb320893bc8887d4fa065488519edeeba82966bcf7c00158fa5771d54f2933ee3">ETH_4_TCS</a> = 4, 
<a class="el" href="rte__ethdev_8h.html#afb320893bc8887d4fa065488519edeeba497a51c3c8a7607c5ad5b6a0e52c0bec">ETH_8_TCS</a> = 8
 }</td></tr>
<tr class="separator:afb320893bc8887d4fa065488519edeeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012a874434677984af1f026ad585dd0d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a012a874434677984af1f026ad585dd0d">rte_eth_nb_pools</a> { <a class="el" href="rte__ethdev_8h.html#a012a874434677984af1f026ad585dd0da308323e3152afc591f57f613d2418eae">ETH_8_POOLS</a> = 8, 
<a class="el" href="rte__ethdev_8h.html#a012a874434677984af1f026ad585dd0da6fc3611a78373485755c1745fd5949f3">ETH_16_POOLS</a> = 16, 
<a class="el" href="rte__ethdev_8h.html#a012a874434677984af1f026ad585dd0da84c1f9fff8d568cc7718cacfe503ee40">ETH_32_POOLS</a> = 32, 
<a class="el" href="rte__ethdev_8h.html#a012a874434677984af1f026ad585dd0da6d8ac01047480b34f6963a0d9d21ddf2">ETH_64_POOLS</a> = 64
 }</td></tr>
<tr class="separator:a012a874434677984af1f026ad585dd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9caad71a6958aaf72dfce61bac897ad3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a9caad71a6958aaf72dfce61bac897ad3">rte_eth_fc_mode</a> { <a class="el" href="rte__ethdev_8h.html#a9caad71a6958aaf72dfce61bac897ad3a612214e57ee035a33a84bf89aafc0fcc">RTE_FC_NONE</a> = 0, 
<a class="el" href="rte__ethdev_8h.html#a9caad71a6958aaf72dfce61bac897ad3af41b8937da7b82e0172537f3e747113b">RTE_FC_RX_PAUSE</a>, 
<a class="el" href="rte__ethdev_8h.html#a9caad71a6958aaf72dfce61bac897ad3ad112a448ab357674c4ad99abae1b8c27">RTE_FC_TX_PAUSE</a>, 
<a class="el" href="rte__ethdev_8h.html#a9caad71a6958aaf72dfce61bac897ad3af6ffb6aa3d299faa0be61fc5f337ded9">RTE_FC_FULL</a>
 }</td></tr>
<tr class="separator:a9caad71a6958aaf72dfce61bac897ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f701a3e5754496d2dff0063717bd88"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac1f701a3e5754496d2dff0063717bd88">rte_fdir_mode</a> { <a class="el" href="rte__ethdev_8h.html#ac1f701a3e5754496d2dff0063717bd88a49cef59325a47ce26833bc05a45575d6">RTE_FDIR_MODE_NONE</a> = 0, 
<a class="el" href="rte__ethdev_8h.html#ac1f701a3e5754496d2dff0063717bd88a999048853d885e0ebd9d6cb836a2e6bf">RTE_FDIR_MODE_SIGNATURE</a>, 
<a class="el" href="rte__ethdev_8h.html#ac1f701a3e5754496d2dff0063717bd88a52832673f79e3b7680f3233fe51065c7">RTE_FDIR_MODE_PERFECT</a>
 }</td></tr>
<tr class="separator:ac1f701a3e5754496d2dff0063717bd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eda431989b68c708c7a875d71592a70"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a9eda431989b68c708c7a875d71592a70">rte_fdir_pballoc_type</a> { <a class="el" href="rte__ethdev_8h.html#a9eda431989b68c708c7a875d71592a70aeb67d5bf14d3e6c963eb627e8c8abc8e">RTE_FDIR_PBALLOC_64K</a> = 0, 
<a class="el" href="rte__ethdev_8h.html#a9eda431989b68c708c7a875d71592a70a4c095c272b86375f3b29c3ce23ca238d">RTE_FDIR_PBALLOC_128K</a>, 
<a class="el" href="rte__ethdev_8h.html#a9eda431989b68c708c7a875d71592a70ab9e7b2208dc797c9e913fb6b003f0548">RTE_FDIR_PBALLOC_256K</a>
 }</td></tr>
<tr class="separator:a9eda431989b68c708c7a875d71592a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7335105af297398262762ce692765b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#acf7335105af297398262762ce692765b">rte_fdir_status_mode</a> { <a class="el" href="rte__ethdev_8h.html#acf7335105af297398262762ce692765bac24f0fb424f6be0210378292be1add92">RTE_FDIR_NO_REPORT_STATUS</a> = 0, 
<a class="el" href="rte__ethdev_8h.html#acf7335105af297398262762ce692765bab49c02f6409e08d0dedae3d57ab17507">RTE_FDIR_REPORT_STATUS</a>, 
<a class="el" href="rte__ethdev_8h.html#acf7335105af297398262762ce692765bad952da675964dab34452bb9efa07ad46">RTE_FDIR_REPORT_STATUS_ALWAYS</a>
 }</td></tr>
<tr class="separator:acf7335105af297398262762ce692765b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438bfb53a537ee87e81104affb6a0712"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a438bfb53a537ee87e81104affb6a0712">rte_l4type</a> { <a class="el" href="rte__ethdev_8h.html#a438bfb53a537ee87e81104affb6a0712afe1df6f7bd34e30c30f7194c17e0ba51">RTE_FDIR_L4TYPE_NONE</a> = 0, 
<a class="el" href="rte__ethdev_8h.html#a438bfb53a537ee87e81104affb6a0712acf8d433c8a6cac2f2f5297926a096edc">RTE_FDIR_L4TYPE_UDP</a>, 
<a class="el" href="rte__ethdev_8h.html#a438bfb53a537ee87e81104affb6a0712a5ba555e38f0fb9a9af263102d4d7e3b3">RTE_FDIR_L4TYPE_TCP</a>, 
<a class="el" href="rte__ethdev_8h.html#a438bfb53a537ee87e81104affb6a0712a92739d6622f4172deb1a9027322a66fc">RTE_FDIR_L4TYPE_SCTP</a>
 }</td></tr>
<tr class="separator:a438bfb53a537ee87e81104affb6a0712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3327734f777895234ece5ea5de0c780"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ab3327734f777895234ece5ea5de0c780">rte_iptype</a> { <a class="el" href="rte__ethdev_8h.html#ab3327734f777895234ece5ea5de0c780aebec00f336b0666124aa17ad435f4cf4">RTE_FDIR_IPTYPE_IPV4</a> = 0, 
<a class="el" href="rte__ethdev_8h.html#ab3327734f777895234ece5ea5de0c780abe40d851439cafc8416031dc11aaa635">RTE_FDIR_IPTYPE_IPV6</a>
 }</td></tr>
<tr class="separator:ab3327734f777895234ece5ea5de0c780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6788469a92700a583d06bf079d779d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779d">rte_eth_event_type</a> { <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779da0da770e4c0207ac9c358c974ff830716">RTE_ETH_EVENT_UNKNOWN</a>, 
<a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779dad4b7ae5186810a8eacba937ac45d6a73">RTE_ETH_EVENT_INTR_LSC</a>, 
<a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779daf036573c1c236f5780892cb4fadaa7e6">RTE_ETH_EVENT_MAX</a>
 }</td></tr>
<tr class="separator:a1e6788469a92700a583d06bf079d779d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac228551f31e57645c7bb5efd1db2e63d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac228551f31e57645c7bb5efd1db2e63d">rte_eth_dev_count</a> (void)</td></tr>
<tr class="separator:ac228551f31e57645c7bb5efd1db2e63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20aa121231e3e0a9e705619ebf84983"><td class="memItemLeft" align="right" valign="top">struct rte_eth_dev *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af20aa121231e3e0a9e705619ebf84983">rte_eth_dev_allocate</a> (const char *name)</td></tr>
<tr class="separator:af20aa121231e3e0a9e705619ebf84983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30d075b4b206c7122e200164ce69893"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac30d075b4b206c7122e200164ce69893">rte_eth_dev_configure</a> (uint8_t port_id, uint16_t nb_rx_queue, uint16_t nb_tx_queue, const struct <a class="el" href="structrte__eth__conf.html">rte_eth_conf</a> *eth_conf)</td></tr>
<tr class="separator:ac30d075b4b206c7122e200164ce69893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db38c1bb895250a99b217bb24126d8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a8db38c1bb895250a99b217bb24126d8e">rte_eth_rx_queue_setup</a> (uint8_t port_id, uint16_t rx_queue_id, uint16_t nb_rx_desc, unsigned int socket_id, const struct <a class="el" href="structrte__eth__rxconf.html">rte_eth_rxconf</a> *rx_conf, struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mb_pool)</td></tr>
<tr class="separator:a8db38c1bb895250a99b217bb24126d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b9fe682d4487fb3efecc40d08d04a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af4b9fe682d4487fb3efecc40d08d04a7">rte_eth_tx_queue_setup</a> (uint8_t port_id, uint16_t tx_queue_id, uint16_t nb_tx_desc, unsigned int socket_id, const struct <a class="el" href="structrte__eth__txconf.html">rte_eth_txconf</a> *tx_conf)</td></tr>
<tr class="separator:af4b9fe682d4487fb3efecc40d08d04a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cdec593efa6b9809e711ade3a2fe24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ab6cdec593efa6b9809e711ade3a2fe24">rte_eth_dev_start</a> (uint8_t port_id)</td></tr>
<tr class="separator:ab6cdec593efa6b9809e711ade3a2fe24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322fa275f154022db7bce02ee95e5612"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a322fa275f154022db7bce02ee95e5612">rte_eth_dev_stop</a> (uint8_t port_id)</td></tr>
<tr class="separator:a322fa275f154022db7bce02ee95e5612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29198523ea850aa2045bc8654f62574"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad29198523ea850aa2045bc8654f62574">rte_eth_dev_set_link_up</a> (uint8_t port_id)</td></tr>
<tr class="separator:ad29198523ea850aa2045bc8654f62574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd9012303eae348ada932a671b752bc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a1fd9012303eae348ada932a671b752bc">rte_eth_dev_set_link_down</a> (uint8_t port_id)</td></tr>
<tr class="separator:a1fd9012303eae348ada932a671b752bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f303682c9ee2aa48d58ffd812d842d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af8f303682c9ee2aa48d58ffd812d842d">rte_eth_dev_close</a> (uint8_t port_id)</td></tr>
<tr class="separator:af8f303682c9ee2aa48d58ffd812d842d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8064b25aee324bdbbf779ea23d55f49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aa8064b25aee324bdbbf779ea23d55f49">rte_eth_promiscuous_enable</a> (uint8_t port_id)</td></tr>
<tr class="separator:aa8064b25aee324bdbbf779ea23d55f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af115d34c99a974996a9b70bdee86a58b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af115d34c99a974996a9b70bdee86a58b">rte_eth_promiscuous_disable</a> (uint8_t port_id)</td></tr>
<tr class="separator:af115d34c99a974996a9b70bdee86a58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3569838a05625c5dbbaaad74872fcfd4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a3569838a05625c5dbbaaad74872fcfd4">rte_eth_promiscuous_get</a> (uint8_t port_id)</td></tr>
<tr class="separator:a3569838a05625c5dbbaaad74872fcfd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8432a0c27f9802ace08debf905f85d9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a8432a0c27f9802ace08debf905f85d9a">rte_eth_allmulticast_enable</a> (uint8_t port_id)</td></tr>
<tr class="separator:a8432a0c27f9802ace08debf905f85d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249a40c851f6228c72e65867618e5f49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a249a40c851f6228c72e65867618e5f49">rte_eth_allmulticast_disable</a> (uint8_t port_id)</td></tr>
<tr class="separator:a249a40c851f6228c72e65867618e5f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ccfba7aea644ec8b64ed13957139aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a98ccfba7aea644ec8b64ed13957139aa">rte_eth_allmulticast_get</a> (uint8_t port_id)</td></tr>
<tr class="separator:a98ccfba7aea644ec8b64ed13957139aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ceaee11c58efd9c12ef7d2f99f87445"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a1ceaee11c58efd9c12ef7d2f99f87445">rte_eth_link_get</a> (uint8_t port_id, struct <a class="el" href="structrte__eth__link.html">rte_eth_link</a> *link)</td></tr>
<tr class="separator:a1ceaee11c58efd9c12ef7d2f99f87445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6908b1ef94c95ef85af851e6705a5f93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a6908b1ef94c95ef85af851e6705a5f93">rte_eth_link_get_nowait</a> (uint8_t port_id, struct <a class="el" href="structrte__eth__link.html">rte_eth_link</a> *link)</td></tr>
<tr class="separator:a6908b1ef94c95ef85af851e6705a5f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7b274a66c959f827a0750eaf22a5cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aac7b274a66c959f827a0750eaf22a5cb">rte_eth_stats_get</a> (uint8_t port_id, struct <a class="el" href="structrte__eth__stats.html">rte_eth_stats</a> *stats)</td></tr>
<tr class="separator:aac7b274a66c959f827a0750eaf22a5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d4c21999ce13ae488b825e597645a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac2d4c21999ce13ae488b825e597645a5">rte_eth_stats_reset</a> (uint8_t port_id)</td></tr>
<tr class="separator:ac2d4c21999ce13ae488b825e597645a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb6267902e47293ef419cb44dd1d54c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a3fb6267902e47293ef419cb44dd1d54c">rte_eth_dev_set_tx_queue_stats_mapping</a> (uint8_t port_id, uint16_t tx_queue_id, uint8_t stat_idx)</td></tr>
<tr class="separator:a3fb6267902e47293ef419cb44dd1d54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ea35870991fb68a574d69fc74d186a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad7ea35870991fb68a574d69fc74d186a">rte_eth_dev_set_rx_queue_stats_mapping</a> (uint8_t port_id, uint16_t rx_queue_id, uint8_t stat_idx)</td></tr>
<tr class="separator:ad7ea35870991fb68a574d69fc74d186a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5686df2817980236f2c4f1cc72dd2c30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a5686df2817980236f2c4f1cc72dd2c30">rte_eth_macaddr_get</a> (uint8_t port_id, struct <a class="el" href="structether__addr.html">ether_addr</a> *mac_addr)</td></tr>
<tr class="separator:a5686df2817980236f2c4f1cc72dd2c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469a98f6245c85d14f58af8f73168d8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a469a98f6245c85d14f58af8f73168d8b">rte_eth_dev_info_get</a> (uint8_t port_id, struct rte_eth_dev_info *dev_info)</td></tr>
<tr class="separator:a469a98f6245c85d14f58af8f73168d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b91165080d12c057cb82c7f38a0d44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a89b91165080d12c057cb82c7f38a0d44">rte_eth_dev_get_mtu</a> (uint8_t port_id, uint16_t *mtu)</td></tr>
<tr class="separator:a89b91165080d12c057cb82c7f38a0d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f4a53ed758fe04a9e4f554a4d500e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ab1f4a53ed758fe04a9e4f554a4d500e0">rte_eth_dev_set_mtu</a> (uint8_t port_id, uint16_t mtu)</td></tr>
<tr class="separator:ab1f4a53ed758fe04a9e4f554a4d500e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b4af0fa671325b33ce8841b96ae997"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a76b4af0fa671325b33ce8841b96ae997">rte_eth_dev_vlan_filter</a> (uint8_t port_id, uint16_t vlan_id, int on)</td></tr>
<tr class="separator:a76b4af0fa671325b33ce8841b96ae997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fd035ce805444a3df4738a5c53fa62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a15fd035ce805444a3df4738a5c53fa62">rte_eth_dev_set_vlan_strip_on_queue</a> (uint8_t port_id, uint16_t rx_queue_id, int on)</td></tr>
<tr class="separator:a15fd035ce805444a3df4738a5c53fa62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf909eed7c681230644ea0ec2ad5ef6f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#adf909eed7c681230644ea0ec2ad5ef6f">rte_eth_dev_set_vlan_ether_type</a> (uint8_t port_id, uint16_t tag_type)</td></tr>
<tr class="separator:adf909eed7c681230644ea0ec2ad5ef6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5de5f589820b7b65b8197150cb2feaf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad5de5f589820b7b65b8197150cb2feaf">rte_eth_dev_set_vlan_offload</a> (uint8_t port_id, int offload_mask)</td></tr>
<tr class="separator:ad5de5f589820b7b65b8197150cb2feaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94784b4dde62cbbeedc3b3bed14dc1f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ae94784b4dde62cbbeedc3b3bed14dc1f">rte_eth_dev_get_vlan_offload</a> (uint8_t port_id)</td></tr>
<tr class="separator:ae94784b4dde62cbbeedc3b3bed14dc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde16bf1f8ff2d660678f597c6fd4896"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#afde16bf1f8ff2d660678f597c6fd4896">rte_eth_dev_set_vlan_pvid</a> (uint8_t port_id, uint16_t pvid, int on)</td></tr>
<tr class="separator:afde16bf1f8ff2d660678f597c6fd4896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac93faa0f3f69545ca121dcfd9433f5"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a5ac93faa0f3f69545ca121dcfd9433f5">rte_eth_rx_burst</a> (uint8_t port_id, uint16_t queue_id, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **rx_pkts, uint16_t nb_pkts)</td></tr>
<tr class="separator:a5ac93faa0f3f69545ca121dcfd9433f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17612542dc1d0df1584819eb41a04b4c"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a17612542dc1d0df1584819eb41a04b4c">rte_eth_rx_queue_count</a> (uint8_t port_id, uint16_t queue_id)</td></tr>
<tr class="separator:a17612542dc1d0df1584819eb41a04b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab617761e283b6a5e1c925ab6631e384a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ab617761e283b6a5e1c925ab6631e384a">rte_eth_rx_descriptor_done</a> (uint8_t port_id, uint16_t queue_id, uint16_t offset)</td></tr>
<tr class="separator:ab617761e283b6a5e1c925ab6631e384a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8053f1efd106a1d939e77f97566846b0"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a8053f1efd106a1d939e77f97566846b0">rte_eth_tx_burst</a> (uint8_t port_id, uint16_t queue_id, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **tx_pkts, uint16_t nb_pkts)</td></tr>
<tr class="separator:a8053f1efd106a1d939e77f97566846b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef515ffe18b57bed5493bcea90f16d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a4ef515ffe18b57bed5493bcea90f16d7">rte_eth_dev_fdir_add_signature_filter</a> (uint8_t port_id, struct <a class="el" href="structrte__fdir__filter.html">rte_fdir_filter</a> *fdir_filter, uint8_t rx_queue)</td></tr>
<tr class="separator:a4ef515ffe18b57bed5493bcea90f16d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13340acf9108d1ef878ab82e3c53a22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ae13340acf9108d1ef878ab82e3c53a22">rte_eth_dev_fdir_update_signature_filter</a> (uint8_t port_id, struct <a class="el" href="structrte__fdir__filter.html">rte_fdir_filter</a> *fdir_ftr, uint8_t rx_queue)</td></tr>
<tr class="separator:ae13340acf9108d1ef878ab82e3c53a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fdd145f92f7195411165dcb25e4ff9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad3fdd145f92f7195411165dcb25e4ff9">rte_eth_dev_fdir_remove_signature_filter</a> (uint8_t port_id, struct <a class="el" href="structrte__fdir__filter.html">rte_fdir_filter</a> *fdir_ftr)</td></tr>
<tr class="separator:ad3fdd145f92f7195411165dcb25e4ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546527cc9b28e1a37a4e0be5f951243e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a546527cc9b28e1a37a4e0be5f951243e">rte_eth_dev_fdir_get_infos</a> (uint8_t port_id, struct <a class="el" href="structrte__eth__fdir.html">rte_eth_fdir</a> *fdir)</td></tr>
<tr class="separator:a546527cc9b28e1a37a4e0be5f951243e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5782c072f8daebd23a7a048d9b21fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a4b5782c072f8daebd23a7a048d9b21fc">rte_eth_dev_fdir_add_perfect_filter</a> (uint8_t port_id, struct <a class="el" href="structrte__fdir__filter.html">rte_fdir_filter</a> *fdir_filter, uint16_t soft_id, uint8_t rx_queue, uint8_t drop)</td></tr>
<tr class="separator:a4b5782c072f8daebd23a7a048d9b21fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025b75c743312a2ca328bb4f3c6e5df1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a025b75c743312a2ca328bb4f3c6e5df1">rte_eth_dev_fdir_update_perfect_filter</a> (uint8_t port_id, struct <a class="el" href="structrte__fdir__filter.html">rte_fdir_filter</a> *fdir_filter, uint16_t soft_id, uint8_t rx_queue, uint8_t drop)</td></tr>
<tr class="separator:a025b75c743312a2ca328bb4f3c6e5df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae57f0c90e84bf440e0499dd17ab8252"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aae57f0c90e84bf440e0499dd17ab8252">rte_eth_dev_fdir_remove_perfect_filter</a> (uint8_t port_id, struct <a class="el" href="structrte__fdir__filter.html">rte_fdir_filter</a> *fdir_filter, uint16_t soft_id)</td></tr>
<tr class="separator:aae57f0c90e84bf440e0499dd17ab8252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99d956b16278a9fd05e9068f04031ec"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ab99d956b16278a9fd05e9068f04031ec">rte_eth_dev_fdir_set_masks</a> (uint8_t port_id, struct <a class="el" href="structrte__fdir__masks.html">rte_fdir_masks</a> *fdir_mask)</td></tr>
<tr class="separator:ab99d956b16278a9fd05e9068f04031ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1527b4d69614354984ae65fc72362b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a9f1527b4d69614354984ae65fc72362b">rte_eth_dev_callback_register</a> (uint8_t port_id, enum <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779d">rte_eth_event_type</a> event, <a class="el" href="rte__ethdev_8h.html#a26f17da8528d43edd6810815530ee954">rte_eth_dev_cb_fn</a> cb_fn, void *cb_arg)</td></tr>
<tr class="separator:a9f1527b4d69614354984ae65fc72362b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56829d8b02096b6a55bed7b5038aaad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af56829d8b02096b6a55bed7b5038aaad">rte_eth_dev_callback_unregister</a> (uint8_t port_id, enum <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779d">rte_eth_event_type</a> event, <a class="el" href="rte__ethdev_8h.html#a26f17da8528d43edd6810815530ee954">rte_eth_dev_cb_fn</a> cb_fn, void *cb_arg)</td></tr>
<tr class="separator:af56829d8b02096b6a55bed7b5038aaad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7098a4ca8bc507c3064719ba96be8f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac7098a4ca8bc507c3064719ba96be8f9">rte_eth_led_on</a> (uint8_t port_id)</td></tr>
<tr class="separator:ac7098a4ca8bc507c3064719ba96be8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00483521d3e5274d2976a78525d507e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac00483521d3e5274d2976a78525d507e">rte_eth_led_off</a> (uint8_t port_id)</td></tr>
<tr class="separator:ac00483521d3e5274d2976a78525d507e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ae9db8ce587e2391fe73aa8e9878f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a42ae9db8ce587e2391fe73aa8e9878f7">rte_eth_dev_flow_ctrl_get</a> (uint8_t port_id, struct <a class="el" href="structrte__eth__fc__conf.html">rte_eth_fc_conf</a> *fc_conf)</td></tr>
<tr class="separator:a42ae9db8ce587e2391fe73aa8e9878f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55335f4dbf971dddc9dbbbdad08e491"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ab55335f4dbf971dddc9dbbbdad08e491">rte_eth_dev_flow_ctrl_set</a> (uint8_t port_id, struct <a class="el" href="structrte__eth__fc__conf.html">rte_eth_fc_conf</a> *fc_conf)</td></tr>
<tr class="separator:ab55335f4dbf971dddc9dbbbdad08e491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03eb9093c037eb9ea96f8e6551e71ea5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a03eb9093c037eb9ea96f8e6551e71ea5">rte_eth_dev_priority_flow_ctrl_set</a> (uint8_t port_id, struct <a class="el" href="structrte__eth__pfc__conf.html">rte_eth_pfc_conf</a> *pfc_conf)</td></tr>
<tr class="separator:a03eb9093c037eb9ea96f8e6551e71ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b81750086f5f9e55cf65e5cf9f2c58"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aa2b81750086f5f9e55cf65e5cf9f2c58">rte_eth_dev_mac_addr_add</a> (uint8_t port, struct <a class="el" href="structether__addr.html">ether_addr</a> *mac_addr, uint32_t pool)</td></tr>
<tr class="separator:aa2b81750086f5f9e55cf65e5cf9f2c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6dce3e24e3443c64da7f5ace3ddf36b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad6dce3e24e3443c64da7f5ace3ddf36b">rte_eth_dev_mac_addr_remove</a> (uint8_t port, struct <a class="el" href="structether__addr.html">ether_addr</a> *mac_addr)</td></tr>
<tr class="separator:ad6dce3e24e3443c64da7f5ace3ddf36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa851e1a7beae2bdbd80e4194fdcf6558"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aa851e1a7beae2bdbd80e4194fdcf6558">rte_eth_dev_rss_reta_update</a> (uint8_t port, struct <a class="el" href="structrte__eth__rss__reta.html">rte_eth_rss_reta</a> *reta_conf)</td></tr>
<tr class="separator:aa851e1a7beae2bdbd80e4194fdcf6558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80e7b9b2ec61bd9ac760da4b5d09e77"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac80e7b9b2ec61bd9ac760da4b5d09e77">rte_eth_dev_rss_reta_query</a> (uint8_t port, struct <a class="el" href="structrte__eth__rss__reta.html">rte_eth_rss_reta</a> *reta_conf)</td></tr>
<tr class="separator:ac80e7b9b2ec61bd9ac760da4b5d09e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309791aea821c7024dd6922ddf0cc4af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a309791aea821c7024dd6922ddf0cc4af">rte_eth_dev_uc_hash_table_set</a> (uint8_t port, struct <a class="el" href="structether__addr.html">ether_addr</a> *addr, uint8_t on)</td></tr>
<tr class="separator:a309791aea821c7024dd6922ddf0cc4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebec36d812fa2f8fb26ebcfc6697ff4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aeebec36d812fa2f8fb26ebcfc6697ff4">rte_eth_dev_uc_all_hash_table_set</a> (uint8_t port, uint8_t on)</td></tr>
<tr class="separator:aeebec36d812fa2f8fb26ebcfc6697ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a19a56a4540b023b5d6ddb759f79d37"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a0a19a56a4540b023b5d6ddb759f79d37">rte_eth_dev_set_vf_rxmode</a> (uint8_t port, uint16_t vf, uint16_t rx_mode, uint8_t on)</td></tr>
<tr class="separator:a0a19a56a4540b023b5d6ddb759f79d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267488519b53e4eea68fa23347d31c0c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a267488519b53e4eea68fa23347d31c0c">rte_eth_dev_set_vf_tx</a> (uint8_t port, uint16_t vf, uint8_t on)</td></tr>
<tr class="separator:a267488519b53e4eea68fa23347d31c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02ac76da48829829a067d2f2ab3d59b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad02ac76da48829829a067d2f2ab3d59b">rte_eth_dev_set_vf_rx</a> (uint8_t port, uint16_t vf, uint8_t on)</td></tr>
<tr class="separator:ad02ac76da48829829a067d2f2ab3d59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d04b22971d05ea8c7db12342b1333a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a8d04b22971d05ea8c7db12342b1333a0">rte_eth_dev_set_vf_vlan_filter</a> (uint8_t port, uint16_t vlan_id, uint64_t vf_mask, uint8_t vlan_on)</td></tr>
<tr class="separator:a8d04b22971d05ea8c7db12342b1333a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d674fb5acf9b35269713e49c4e5977"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a71d674fb5acf9b35269713e49c4e5977">rte_eth_mirror_rule_set</a> (uint8_t port_id, struct <a class="el" href="structrte__eth__vmdq__mirror__conf.html">rte_eth_vmdq_mirror_conf</a> *mirror_conf, uint8_t rule_id, uint8_t on)</td></tr>
<tr class="separator:a71d674fb5acf9b35269713e49c4e5977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cca95dda28adc353f571499b9e027f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a6cca95dda28adc353f571499b9e027f9">rte_eth_mirror_rule_reset</a> (uint8_t port_id, uint8_t rule_id)</td></tr>
<tr class="separator:a6cca95dda28adc353f571499b9e027f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f26d83cdddce57512653a811244e22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af2f26d83cdddce57512653a811244e22">rte_eth_set_queue_rate_limit</a> (uint8_t port_id, uint16_t queue_idx, uint16_t tx_rate)</td></tr>
<tr class="separator:af2f26d83cdddce57512653a811244e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84873c5b3c3968e8e18ca3043750f7cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a84873c5b3c3968e8e18ca3043750f7cd">rte_eth_set_vf_rate_limit</a> (uint8_t port_id, uint16_t vf, uint16_t tx_rate, uint64_t q_msk)</td></tr>
<tr class="separator:a84873c5b3c3968e8e18ca3043750f7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c1155e6337a225bb25f09b445ff5f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a65c1155e6337a225bb25f09b445ff5f1">rte_eth_dev_bypass_init</a> (uint8_t port)</td></tr>
<tr class="separator:a65c1155e6337a225bb25f09b445ff5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e74e4854876fbc91ee6c3f164b2e13"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ad3e74e4854876fbc91ee6c3f164b2e13">rte_eth_dev_bypass_state_show</a> (uint8_t port, uint32_t *state)</td></tr>
<tr class="separator:ad3e74e4854876fbc91ee6c3f164b2e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2094bade4ba6174124a5a3b56991833"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af2094bade4ba6174124a5a3b56991833">rte_eth_dev_bypass_state_set</a> (uint8_t port, uint32_t *new_state)</td></tr>
<tr class="separator:af2094bade4ba6174124a5a3b56991833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab067ba3ed3c3e663ec0e2e45721baa73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ab067ba3ed3c3e663ec0e2e45721baa73">rte_eth_dev_bypass_event_show</a> (uint8_t port, uint32_t event, uint32_t *state)</td></tr>
<tr class="separator:ab067ba3ed3c3e663ec0e2e45721baa73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde602eff86b7574cbd961ee1b41ee7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#afde602eff86b7574cbd961ee1b41ee7f">rte_eth_dev_bypass_event_store</a> (uint8_t port, uint32_t event, uint32_t state)</td></tr>
<tr class="separator:afde602eff86b7574cbd961ee1b41ee7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac114558859d52cf2117e93efe6ab0630"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac114558859d52cf2117e93efe6ab0630">rte_eth_dev_wd_timeout_store</a> (uint8_t port, uint32_t timeout)</td></tr>
<tr class="separator:ac114558859d52cf2117e93efe6ab0630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c874ce7b7411063749681bdae7b976"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a11c874ce7b7411063749681bdae7b976">rte_eth_dev_bypass_ver_show</a> (uint8_t port, uint32_t *ver)</td></tr>
<tr class="separator:a11c874ce7b7411063749681bdae7b976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92494342ed7227bd54a9d13a9a96ccf9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a92494342ed7227bd54a9d13a9a96ccf9">rte_eth_dev_bypass_wd_timeout_show</a> (uint8_t port, uint32_t *wd_timeout)</td></tr>
<tr class="separator:a92494342ed7227bd54a9d13a9a96ccf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bdf2f73208a71e3184e7110dd772ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ab1bdf2f73208a71e3184e7110dd772ce">rte_eth_dev_bypass_wd_reset</a> (uint8_t port)</td></tr>
<tr class="separator:ab1bdf2f73208a71e3184e7110dd772ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6444b5ab7f425c7ccb02a980cecce52"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ac6444b5ab7f425c7ccb02a980cecce52">rte_eth_dev_rss_hash_update</a> (uint8_t port_id, struct <a class="el" href="structrte__eth__rss__conf.html">rte_eth_rss_conf</a> *rss_conf)</td></tr>
<tr class="separator:ac6444b5ab7f425c7ccb02a980cecce52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ab8e6bf1417381440d51f49bffafc1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a65ab8e6bf1417381440d51f49bffafc1">rte_eth_dev_rss_hash_conf_get</a> (uint8_t port_id, struct <a class="el" href="structrte__eth__rss__conf.html">rte_eth_rss_conf</a> *rss_conf)</td></tr>
<tr class="separator:a65ab8e6bf1417381440d51f49bffafc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21729867669488dc2f22d923a856a966"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a21729867669488dc2f22d923a856a966">rte_eth_dev_add_syn_filter</a> (uint8_t port_id, struct <a class="el" href="structrte__syn__filter.html">rte_syn_filter</a> *filter, uint16_t rx_queue)</td></tr>
<tr class="separator:a21729867669488dc2f22d923a856a966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af000f142f2cd529df2afdae5f2af0f47"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af000f142f2cd529df2afdae5f2af0f47">rte_eth_dev_remove_syn_filter</a> (uint8_t port_id)</td></tr>
<tr class="separator:af000f142f2cd529df2afdae5f2af0f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edffbdf8ae12681211230535f711992"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a8edffbdf8ae12681211230535f711992">rte_eth_dev_get_syn_filter</a> (uint8_t port_id, struct <a class="el" href="structrte__syn__filter.html">rte_syn_filter</a> *filter, uint16_t *rx_queue)</td></tr>
<tr class="separator:a8edffbdf8ae12681211230535f711992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0dceb40fbe1866728d7dc9b1984edc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#acb0dceb40fbe1866728d7dc9b1984edc">rte_eth_dev_add_ethertype_filter</a> (uint8_t port_id, uint16_t index, struct <a class="el" href="structrte__ethertype__filter.html">rte_ethertype_filter</a> *filter, uint16_t rx_queue)</td></tr>
<tr class="separator:acb0dceb40fbe1866728d7dc9b1984edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b7eac06b4a7e58f330bf719969abe3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a86b7eac06b4a7e58f330bf719969abe3">rte_eth_dev_remove_ethertype_filter</a> (uint8_t port_id, uint16_t index)</td></tr>
<tr class="separator:a86b7eac06b4a7e58f330bf719969abe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea554d71fc2edf3eb00200c74e63603"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a6ea554d71fc2edf3eb00200c74e63603">rte_eth_dev_get_ethertype_filter</a> (uint8_t port_id, uint16_t index, struct <a class="el" href="structrte__ethertype__filter.html">rte_ethertype_filter</a> *filter, uint16_t *rx_queue)</td></tr>
<tr class="separator:a6ea554d71fc2edf3eb00200c74e63603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2dbe6cbeb42b005f0103f566d578094"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af2dbe6cbeb42b005f0103f566d578094">rte_eth_dev_add_2tuple_filter</a> (uint8_t port_id, uint16_t index, struct <a class="el" href="structrte__2tuple__filter.html">rte_2tuple_filter</a> *filter, uint16_t rx_queue)</td></tr>
<tr class="separator:af2dbe6cbeb42b005f0103f566d578094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefcfa984fc0d74cc64867f62a9588d5a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aefcfa984fc0d74cc64867f62a9588d5a">rte_eth_dev_remove_2tuple_filter</a> (uint8_t port_id, uint16_t index)</td></tr>
<tr class="separator:aefcfa984fc0d74cc64867f62a9588d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebb7d5ecf1468b8c8a3fe5c3f5c2ba3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a1ebb7d5ecf1468b8c8a3fe5c3f5c2ba3">rte_eth_dev_get_2tuple_filter</a> (uint8_t port_id, uint16_t index, struct <a class="el" href="structrte__2tuple__filter.html">rte_2tuple_filter</a> *filter, uint16_t *rx_queue)</td></tr>
<tr class="separator:a1ebb7d5ecf1468b8c8a3fe5c3f5c2ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa28adafa65a4f47d4aeceaf1b08381b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#aaa28adafa65a4f47d4aeceaf1b08381b">rte_eth_dev_add_5tuple_filter</a> (uint8_t port_id, uint16_t index, struct <a class="el" href="structrte__5tuple__filter.html">rte_5tuple_filter</a> *filter, uint16_t rx_queue)</td></tr>
<tr class="separator:aaa28adafa65a4f47d4aeceaf1b08381b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0f7d77dd40c342f2d06f6fbe763d62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#acc0f7d77dd40c342f2d06f6fbe763d62">rte_eth_dev_remove_5tuple_filter</a> (uint8_t port_id, uint16_t index)</td></tr>
<tr class="separator:acc0f7d77dd40c342f2d06f6fbe763d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14a8e975984710a983586220f91500d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#ae14a8e975984710a983586220f91500d">rte_eth_dev_get_5tuple_filter</a> (uint8_t port_id, uint16_t index, struct <a class="el" href="structrte__5tuple__filter.html">rte_5tuple_filter</a> *filter, uint16_t *rx_queue)</td></tr>
<tr class="separator:ae14a8e975984710a983586220f91500d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6082f80ffda75e5f22a612d473bfbbd0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a6082f80ffda75e5f22a612d473bfbbd0">rte_eth_dev_add_flex_filter</a> (uint8_t port_id, uint16_t index, struct <a class="el" href="structrte__flex__filter.html">rte_flex_filter</a> *filter, uint16_t rx_queue)</td></tr>
<tr class="separator:a6082f80ffda75e5f22a612d473bfbbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9893d23d25a911fbdc5b5adac8c4c46"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#af9893d23d25a911fbdc5b5adac8c4c46">rte_eth_dev_remove_flex_filter</a> (uint8_t port_id, uint16_t index)</td></tr>
<tr class="separator:af9893d23d25a911fbdc5b5adac8c4c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135b7836dd15a5273e1657269a7e73b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__ethdev_8h.html#a135b7836dd15a5273e1657269a7e73b2">rte_eth_dev_get_flex_filter</a> (uint8_t port_id, uint16_t index, struct <a class="el" href="structrte__flex__filter.html">rte_flex_filter</a> *filter, uint16_t *rx_queue)</td></tr>
<tr class="separator:a135b7836dd15a5273e1657269a7e73b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE Ethernet Device API</p>
<p>The Ethernet Device API is composed of two parts:</p>
<ul>
<li>The application-oriented Ethernet API that includes functions to setup an Ethernet device (configure it, setup its RX and TX queues and start it), to get its MAC address, the speed and the status of its physical link, to receive and to transmit packets, and so on.</li>
<li>The driver-oriented Ethernet API that exports a function allowing an Ethernet Poll Mode Driver (PMD) to simultaneously register itself as an Ethernet device driver and as a PCI driver for a set of matching PCI [Ethernet] devices classes.</li>
</ul>
<p>By default, all the functions of the Ethernet Device API exported by a PMD are lock-free functions which assume to not be invoked in parallel on different logical cores to work on the same target object. For instance, the receive function of a PMD cannot be invoked in parallel on two logical cores to poll the same RX queue [of the same port]. Of course, this function can be invoked in parallel by different logical cores on different RX queues. It is the responsibility of the upper level application to enforce this rule.</p>
<p>If needed, parallel accesses by multiple logical cores to shared queues shall be explicitly protected by dedicated inline lock-aware functions built on top of their corresponding lock-free functions of the PMD API.</p>
<p>In all functions of the Ethernet API, the Ethernet device is designated by an integer &gt;= 0 named the device port identifier.</p>
<p>At the Ethernet driver level, Ethernet devices are represented by a generic data structure of type <em>rte_eth_dev</em>.</p>
<p>Ethernet devices are dynamically registered during the PCI probing phase performed at EAL initialization time. When an Ethernet device is being probed, an <em>rte_eth_dev</em> structure and a new port identifier are allocated for that device. Then, the eth_dev_init() function supplied by the Ethernet driver matching the probed PCI device is invoked to properly initialize the device.</p>
<p>The role of the device init function consists of resetting the hardware, checking access to Non-volatile Memory (NVM), reading the MAC address from NVM etc.</p>
<p>If the device init operation is successful, the correspondence between the port identifier assigned to the new device and its associated <em>rte_eth_dev</em> structure is effectively registered. Otherwise, both the <em>rte_eth_dev</em> structure and the port identifier are freed.</p>
<p>The functions exported by the application Ethernet API to setup a device designated by its port identifier must be invoked in the following order:</p><ul>
<li><a class="el" href="rte__ethdev_8h.html#ac30d075b4b206c7122e200164ce69893">rte_eth_dev_configure()</a></li>
<li><a class="el" href="rte__ethdev_8h.html#af4b9fe682d4487fb3efecc40d08d04a7">rte_eth_tx_queue_setup()</a></li>
<li><a class="el" href="rte__ethdev_8h.html#a8db38c1bb895250a99b217bb24126d8e">rte_eth_rx_queue_setup()</a></li>
<li><a class="el" href="rte__ethdev_8h.html#ab6cdec593efa6b9809e711ade3a2fe24">rte_eth_dev_start()</a></li>
</ul>
<p>Then, the network application can invoke, in any order, the functions exported by the Ethernet API to get the MAC address of a given device, to get the speed and the status of a device physical link, to receive/transmit [burst of] packets, and so on.</p>
<p>If the application wants to change the configuration (i.e. call <a class="el" href="rte__ethdev_8h.html#ac30d075b4b206c7122e200164ce69893">rte_eth_dev_configure()</a>, <a class="el" href="rte__ethdev_8h.html#af4b9fe682d4487fb3efecc40d08d04a7">rte_eth_tx_queue_setup()</a>, or <a class="el" href="rte__ethdev_8h.html#a8db38c1bb895250a99b217bb24126d8e">rte_eth_rx_queue_setup()</a>), it must call <a class="el" href="rte__ethdev_8h.html#a322fa275f154022db7bce02ee95e5612">rte_eth_dev_stop()</a> first to stop the device and then do the reconfiguration before calling <a class="el" href="rte__ethdev_8h.html#ab6cdec593efa6b9809e711ade3a2fe24">rte_eth_dev_start()</a> again. The tramsit and receive functions should not be invoked when the device is stopped.</p>
<p>Please note that some configuration is not stored between calls to <a class="el" href="rte__ethdev_8h.html#a322fa275f154022db7bce02ee95e5612">rte_eth_dev_stop()</a>/rte_eth_dev_start(). The following configuration will be retained: </p><pre class="fragment">- flow control settings
- receive mode configuration (promiscuous mode, hardware checksum mode,
  RSS/VMDQ settings etc.)
- VLAN filtering configuration
- MAC addresses supplied to MAC address array
- flow director filtering mode (but not filtering rules)
- NIC queue statistics mappings
</pre><p>Any other configuration will not be stored and will need to be re-entered after a call to <a class="el" href="rte__ethdev_8h.html#ab6cdec593efa6b9809e711ade3a2fe24">rte_eth_dev_start()</a>.</p>
<p>Finally, a network application can close an Ethernet device by invoking the <a class="el" href="rte__ethdev_8h.html#af8f303682c9ee2aa48d58ffd812d842d">rte_eth_dev_close()</a> function.</p>
<p>Each function of the application Ethernet API invokes a specific function of the PMD that controls the target device designated by its port identifier. For this purpose, all device-specific functions of an Ethernet driver are supplied through a set of pointers contained in a generic structure of type <em>eth_dev_ops</em>. The address of the <em>eth_dev_ops</em> structure is stored in the <em>rte_eth_dev</em> structure by the device init function of the Ethernet driver, which is invoked during the PCI probing phase, as explained earlier.</p>
<p>In other words, each function of the Ethernet API simply retrieves the <em>rte_eth_dev</em> structure associated with the device port identifier and performs an indirect invocation of the corresponding driver function supplied in the <em>eth_dev_ops</em> structure of the <em>rte_eth_dev</em> structure.</p>
<p>For performance reasons, the address of the burst-oriented RX and TX functions of the Ethernet driver are not contained in the <em>eth_dev_ops</em> structure. Instead, they are directly stored at the beginning of the <em>rte_eth_dev</em> structure to avoid an extra indirect memory access during their invocation.</p>
<p>RTE ethernet device drivers do not use interrupts for transmitting or receiving. Instead, Ethernet drivers export Poll-Mode receive and transmit functions to applications. Both receive and transmit functions are packet-burst oriented to minimize their cost per packet through the following optimizations:</p>
<ul>
<li>Sharing among multiple packets the incompressible cost of the invocation of receive/transmit functions.</li>
<li>Enabling receive/transmit functions to take advantage of burst-oriented hardware features (L1 cache, prefetch instructions, NIC head/tail registers) to minimize the number of CPU cycles per packet, for instance, by avoiding useless read memory accesses to ring descriptors, or by systematically using arrays of pointers that exactly fit L1 cache line boundaries and sizes.</li>
</ul>
<p>The burst-oriented receive function does not provide any error notification, to avoid the corresponding overhead. As a hint, the upper-level application might check the status of the device link once being systematically returned a 0 value by the receive function of the driver for a given number of tries. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a544a5d22a4be048e8e5395fb965922ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEV_RX_OFFLOAD_VLAN_STRIP&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A structure used to retrieve the contextual information of an Ethernet device, such as the controlling driver of the device, its PCI context, etc... RX offload capabilities of a device. </p>

</div>
</div>
<a class="anchor" id="adaf0af5e228aeb2aaac39622cb6467ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEV_TX_OFFLOAD_VLAN_INSERT&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TX offload capabilities of a device. </p>

</div>
</div>
<a class="anchor" id="aada4dc197e51fc9ddd45c3f80c3cd6fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_DCB_NONE&#160;&#160;&#160;<a class="el" href="rte__ethdev_8h.html#a4834f572f4dd4e46d81ad09b7d5fffd5aada568551470d5f419cd2f3d6b6bfedc">ETH_MQ_TX_NONE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>for tx mq mode backward compatible </p>

</div>
</div>
<a class="anchor" id="ac96f7b85443dc9c8553176315a2e1b26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_DCB_NUM_QUEUES&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum nb. of DCB queues. </p>

</div>
</div>
<a class="anchor" id="a825a952bfb398214537ed14e60af758d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_DCB_NUM_USER_PRIORITIES&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum nb. of DCB priorities. </p>

</div>
</div>
<a class="anchor" id="a3a80c71b5fcc67a53c2efe1692374430"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_DCB_PFC_SUPPORT&#160;&#160;&#160;0x00000002</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Priority Flow Control support. </p>

</div>
</div>
<a class="anchor" id="a39c3436701eb68875ba6404695616554"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_DCB_PG_SUPPORT&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Priority Group(ETS) support. </p>

</div>
</div>
<a class="anchor" id="ae7e049bfb5699883d548628263f16ad7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_LINK_AUTONEG_DUPLEX&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Auto-negotiate duplex. </p>

</div>
</div>
<a class="anchor" id="a042c83951613bf2db5d3056b967041d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_LINK_FULL_DUPLEX&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Full-duplex connection. </p>

</div>
</div>
<a class="anchor" id="a56c07663fb6353f36d0be00c6744f3f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_LINK_HALF_DUPLEX&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Half-duplex connection. </p>

</div>
</div>
<a class="anchor" id="a10e7915541f4d165f5a7ea6e69a7a239"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_LINK_SPEED_10&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>10 megabits/second. </p>

</div>
</div>
<a class="anchor" id="aea145ff8ac2ec81ef9e66703d5c90360"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_LINK_SPEED_100&#160;&#160;&#160;100</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>100 megabits/second. </p>

</div>
</div>
<a class="anchor" id="ab8b0fcfcc5873cad9e15b5686b9e6453"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_LINK_SPEED_1000&#160;&#160;&#160;1000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>1 gigabits/second. </p>

</div>
</div>
<a class="anchor" id="af36b5d80e47efd37116b2ef6c0aa0ace"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_LINK_SPEED_10000&#160;&#160;&#160;10000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>10 gigabits/second. </p>

</div>
</div>
<a class="anchor" id="ac4a1fe61e5db2ae7951532f45f903fb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_LINK_SPEED_10G&#160;&#160;&#160;10000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>alias of 10 gigabits/second. </p>

</div>
</div>
<a class="anchor" id="a293f557c186179155f0eef5c8e42c669"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_LINK_SPEED_20G&#160;&#160;&#160;20000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>20 gigabits/second. </p>

</div>
</div>
<a class="anchor" id="aeb76ba55e97f704ca58e5b20b689d050"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_LINK_SPEED_40G&#160;&#160;&#160;40000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>40 gigabits/second. </p>

</div>
</div>
<a class="anchor" id="ade7de72f6c0f8102d01a0b3438856900"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_LINK_SPEED_AUTONEG&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Auto-negotiate link speed. </p>

</div>
</div>
<a class="anchor" id="a216f71b2f5bd80c770157fc6f24b6997"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_NUM_RECEIVE_MAC_ADDR&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum nb. of receive mac addr. </p>

</div>
</div>
<a class="anchor" id="a8a06d7bfbfc1ac0c6623716b2ba5a829"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_RSS&#160;&#160;&#160;<a class="el" href="rte__ethdev_8h.html#a586b8e86131b4ec0ccaf464e847ccf3eaa06694239b7ecf1efa3c9243b9e7b4c0">ETH_MQ_RX_RSS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>for rx mq mode backward compatible </p>

</div>
</div>
<a class="anchor" id="ac30da5c1c2145999f6b8e0190d1c3e95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_RSS_UDP</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">( \</div>
<div class="line">        ETH_RSS_IPV4 | \</div>
<div class="line">        ETH_RSS_IPV6 | \</div>
<div class="line">        ETH_RSS_IPV4_UDP | \</div>
<div class="line">        ETH_RSS_IPV6_UDP | \</div>
<div class="line">        ETH_RSS_IPV6_UDP_EX | \</div>
<div class="line">        ETH_RSS_NONF_IPV4_UDP | \</div>
<div class="line">        ETH_RSS_NONF_IPV6_UDP)</div>
</div><!-- fragment --><p>Mask of valid RSS hash protocols </p>

</div>
</div>
<a class="anchor" id="ac6c92e990d49639224f73c538aa7f93e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_TXQ_FLAGS_NOMULTMEMP&#160;&#160;&#160;0x0004</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>all bufs come from same mempool </p>

</div>
</div>
<a class="anchor" id="a4902a1d01782ecc690203f9e9df25ee9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_TXQ_FLAGS_NOMULTSEGS&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nb_segs=1 for all mbufs </p>

</div>
</div>
<a class="anchor" id="a2d955036397d06a5cdd04a9206418221"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_TXQ_FLAGS_NOREFCOUNT&#160;&#160;&#160;0x0002</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>refcnt can be ignored </p>

</div>
</div>
<a class="anchor" id="ae8b377dce04cd001079a35f5b7746276"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_TXQ_FLAGS_NOVLANOFFL&#160;&#160;&#160;0x0100</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>disable VLAN offload </p>

</div>
</div>
<a class="anchor" id="aec79bc280fce5e9cd39c02aee4eeebf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_TXQ_FLAGS_NOXSUMSCTP&#160;&#160;&#160;0x0200</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>disable SCTP checksum offload </p>

</div>
</div>
<a class="anchor" id="a908a9cedf54de06cea43ec362a87fa1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_TXQ_FLAGS_NOXSUMTCP&#160;&#160;&#160;0x0800</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>disable TCP checksum offload </p>

</div>
</div>
<a class="anchor" id="a5d1389985a56456cc0996af7fddeba10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_TXQ_FLAGS_NOXSUMUDP&#160;&#160;&#160;0x0400</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>disable UDP checksum offload </p>

</div>
</div>
<a class="anchor" id="af9cbca7a78bd10b5223483283fc3467b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_VLAN_EXTEND_MASK&#160;&#160;&#160;0x0004</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VLAN Extend setting mask </p>

</div>
</div>
<a class="anchor" id="a75707b9e228ba0735d74acb20b359d30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_VLAN_EXTEND_OFFLOAD&#160;&#160;&#160;0x0004</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VLAN Extend On/Off </p>

</div>
</div>
<a class="anchor" id="aee8d27c456f1d17c9ec96326a602a0bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_VLAN_FILTER_MASK&#160;&#160;&#160;0x0002</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VLAN Filter setting mask </p>

</div>
</div>
<a class="anchor" id="a19dad4459c4351837eeebc156abcc964"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_VLAN_FILTER_OFFLOAD&#160;&#160;&#160;0x0002</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VLAN Filter On/Off </p>

</div>
</div>
<a class="anchor" id="aca3fccc96c0353c7ba4df17c5af3cec1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_VLAN_ID_MAX&#160;&#160;&#160;0x0FFF</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VLAN ID is in lower 12 bits </p>

</div>
</div>
<a class="anchor" id="a40188f42e8bac5e53e05b74f384cf8f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_VLAN_STRIP_MASK&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VLAN Strip setting mask </p>

</div>
</div>
<a class="anchor" id="a1625e8d55cc3138ac05eeed1b65cfd8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_VLAN_STRIP_OFFLOAD&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VLAN Strip On/Off </p>

</div>
</div>
<a class="anchor" id="a5cb1059587ee40589f8d9da60107e740"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_VMDQ_ACCEPT_BROADCAST&#160;&#160;&#160;0x0008</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>accept broadcast packets. </p>

</div>
</div>
<a class="anchor" id="a6eaee466b4e51ad3dcb406305dbadf4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_VMDQ_ACCEPT_HASH_MC&#160;&#160;&#160;0x0002</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>accept packets in multicast table . </p>

</div>
</div>
<a class="anchor" id="aa59aeaf95ad1984ce76e298ee1dd8451"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_VMDQ_ACCEPT_HASH_UC&#160;&#160;&#160;0x0004</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>accept packets in unicast table. </p>

</div>
</div>
<a class="anchor" id="ac0109eb1974972c4fc0f964bc4de3b1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_VMDQ_ACCEPT_MULTICAST&#160;&#160;&#160;0x0010</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>multicast promiscuous. </p>

</div>
</div>
<a class="anchor" id="a12dfb4c0db1629988f157a75c84debb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_VMDQ_ACCEPT_UNTAG&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>accept untagged packets. </p>

</div>
</div>
<a class="anchor" id="a4a68aadc20116d23d2408e4595d9d4a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_VMDQ_DCB_NUM_QUEUES&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum nb. of VMDQ DCB queues. </p>

</div>
</div>
<a class="anchor" id="a30fb0bd604952e8ec9ab37495ecd508d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_VMDQ_DOWNLIN_MIRROR&#160;&#160;&#160;0x0004</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Downlink Port Mirroring. </p>

</div>
</div>
<a class="anchor" id="a606a6b69adcfa6dd6c3fa4a31688bd4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_VMDQ_MAX_VLAN_FILTERS&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum nb. of VMDQ vlan filters. </p>

</div>
</div>
<a class="anchor" id="afbfb476ec43e33fb0146b62095a3a191"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_VMDQ_NUM_MIRROR_RULE&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum nb. of mirror rules. . </p>

</div>
</div>
<a class="anchor" id="ae86c9ef9ed563598fa81af6bc93f34a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_VMDQ_NUM_UC_HASH_ARRAY&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum nb. of UC hash array. </p>

</div>
</div>
<a class="anchor" id="ab0e03bee5f8806d7abee5304cd709544"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_VMDQ_POOL_MIRROR&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Virtual Pool Mirroring. </p>

</div>
</div>
<a class="anchor" id="a5cb13991e558a7086a5cee1bac603aec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_VMDQ_UPLINK_MIRROR&#160;&#160;&#160;0x0002</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uplink Port Mirroring. </p>

</div>
</div>
<a class="anchor" id="af251d6a0938ea060afbb80f427be82c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ETH_VMDQ_VLAN_MIRROR&#160;&#160;&#160;0x0008</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VLAN Mirroring. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a384677162d2f5804aed57efee7f439f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* eth_rx_descriptor_done_t) (void *rxq, uint16_t offset)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DD bit of specific RX descriptor </p>

</div>
</div>
<a class="anchor" id="ab6765b205494199f0e9d8c058f94ed72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t(* eth_rx_queue_count_t) (struct rte_eth_dev *dev, uint16_t rx_queue_id)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of available descriptors on a receive queue of an Ethernet device. </p>

</div>
</div>
<a class="anchor" id="a26f17da8528d43edd6810815530ee954"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* rte_eth_dev_cb_fn) (uint8_t port_id, enum <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779d">rte_eth_event_type</a> event, void *cb_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>user application callback to be registered for interrupts </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a1e6788469a92700a583d06bf079d779d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779d">rte_eth_event_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The eth device event type for interrupt, and maybe others in the future. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a1e6788469a92700a583d06bf079d779da0da770e4c0207ac9c358c974ff830716"></a>RTE_ETH_EVENT_UNKNOWN&#160;</td><td class="fielddoc">
<p>unknown event type </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1e6788469a92700a583d06bf079d779dad4b7ae5186810a8eacba937ac45d6a73"></a>RTE_ETH_EVENT_INTR_LSC&#160;</td><td class="fielddoc">
<p>lsc interrupt event </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1e6788469a92700a583d06bf079d779daf036573c1c236f5780892cb4fadaa7e6"></a>RTE_ETH_EVENT_MAX&#160;</td><td class="fielddoc">
<p>max value of this enum </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a9caad71a6958aaf72dfce61bac897ad3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#a9caad71a6958aaf72dfce61bac897ad3">rte_eth_fc_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enum indicates the flow control mode </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a9caad71a6958aaf72dfce61bac897ad3a612214e57ee035a33a84bf89aafc0fcc"></a>RTE_FC_NONE&#160;</td><td class="fielddoc">
<p>Disable flow control. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9caad71a6958aaf72dfce61bac897ad3af41b8937da7b82e0172537f3e747113b"></a>RTE_FC_RX_PAUSE&#160;</td><td class="fielddoc">
<p>RX pause frame, enable flowctrl on TX side. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9caad71a6958aaf72dfce61bac897ad3ad112a448ab357674c4ad99abae1b8c27"></a>RTE_FC_TX_PAUSE&#160;</td><td class="fielddoc">
<p>TX pause frame, enable flowctrl on RX side. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9caad71a6958aaf72dfce61bac897ad3af6ffb6aa3d299faa0be61fc5f337ded9"></a>RTE_FC_FULL&#160;</td><td class="fielddoc">
<p>Enable flow control on both side. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a012a874434677984af1f026ad585dd0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#a012a874434677984af1f026ad585dd0d">rte_eth_nb_pools</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enum indicates the possible number of queue pools in VMDQ configurations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a012a874434677984af1f026ad585dd0da308323e3152afc591f57f613d2418eae"></a>ETH_8_POOLS&#160;</td><td class="fielddoc">
<p>8 VMDq pools. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a012a874434677984af1f026ad585dd0da6fc3611a78373485755c1745fd5949f3"></a>ETH_16_POOLS&#160;</td><td class="fielddoc">
<p>16 VMDq pools. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a012a874434677984af1f026ad585dd0da84c1f9fff8d568cc7718cacfe503ee40"></a>ETH_32_POOLS&#160;</td><td class="fielddoc">
<p>32 VMDq pools. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a012a874434677984af1f026ad585dd0da6d8ac01047480b34f6963a0d9d21ddf2"></a>ETH_64_POOLS&#160;</td><td class="fielddoc">
<p>64 VMDq pools. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="afb320893bc8887d4fa065488519edeeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#afb320893bc8887d4fa065488519edeeb">rte_eth_nb_tcs</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enum indicates the possible number of traffic classes in DCB configratioins </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="afb320893bc8887d4fa065488519edeeba82966bcf7c00158fa5771d54f2933ee3"></a>ETH_4_TCS&#160;</td><td class="fielddoc">
<p>4 TCs with DCB. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="afb320893bc8887d4fa065488519edeeba497a51c3c8a7607c5ad5b6a0e52c0bec"></a>ETH_8_TCS&#160;</td><td class="fielddoc">
<p>8 TCs with DCB. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a586b8e86131b4ec0ccaf464e847ccf3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#a586b8e86131b4ec0ccaf464e847ccf3e">rte_eth_rx_mq_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A set of values to identify what method is to be used to route packets to multiple queues. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a586b8e86131b4ec0ccaf464e847ccf3ea4600ff07419327deb9b8534bc66daf19"></a>ETH_MQ_RX_NONE&#160;</td><td class="fielddoc">
<p>None of DCB,RSS or VMDQ mode </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a586b8e86131b4ec0ccaf464e847ccf3eaa06694239b7ecf1efa3c9243b9e7b4c0"></a>ETH_MQ_RX_RSS&#160;</td><td class="fielddoc">
<p>For RX side, only RSS is on </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a586b8e86131b4ec0ccaf464e847ccf3eaf85cf063ed90d84431c8b187d5a28e18"></a>ETH_MQ_RX_DCB&#160;</td><td class="fielddoc">
<p>For RX side,only DCB is on. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a586b8e86131b4ec0ccaf464e847ccf3ea4874831bf9e11694ddcc277a63081525"></a>ETH_MQ_RX_DCB_RSS&#160;</td><td class="fielddoc">
<p>Both DCB and RSS enable </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a586b8e86131b4ec0ccaf464e847ccf3ea66316d2ff53011a3209207734c124f3c"></a>ETH_MQ_RX_VMDQ_ONLY&#160;</td><td class="fielddoc">
<p>Only VMDQ, no RSS nor DCB </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a586b8e86131b4ec0ccaf464e847ccf3ea2986c2bbbe392a5e9edade916d25ab5a"></a>ETH_MQ_RX_VMDQ_RSS&#160;</td><td class="fielddoc">
<p>RSS mode with VMDQ </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a586b8e86131b4ec0ccaf464e847ccf3eae4fac92d0a259418226116609963a13d"></a>ETH_MQ_RX_VMDQ_DCB&#160;</td><td class="fielddoc">
<p>Use VMDQ+DCB to route traffic to queues </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a586b8e86131b4ec0ccaf464e847ccf3eaed91aee4ae666352679780578589a121"></a>ETH_MQ_RX_VMDQ_DCB_RSS&#160;</td><td class="fielddoc">
<p>Enable both VMDQ and DCB in VMDq </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a4834f572f4dd4e46d81ad09b7d5fffd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#a4834f572f4dd4e46d81ad09b7d5fffd5">rte_eth_tx_mq_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A set of values to identify what method is to be used to transmit packets using multi-TCs. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a4834f572f4dd4e46d81ad09b7d5fffd5aada568551470d5f419cd2f3d6b6bfedc"></a>ETH_MQ_TX_NONE&#160;</td><td class="fielddoc">
<p>It is in neither DCB nor VT mode. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4834f572f4dd4e46d81ad09b7d5fffd5ae53e78000f917e8d801a4cc9e354626d"></a>ETH_MQ_TX_DCB&#160;</td><td class="fielddoc">
<p>For TX side,only DCB is on. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4834f572f4dd4e46d81ad09b7d5fffd5a82109e803fcd709168e1ef8aa511dd97"></a>ETH_MQ_TX_VMDQ_DCB&#160;</td><td class="fielddoc">
<p>For TX side,both DCB and VT is on. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4834f572f4dd4e46d81ad09b7d5fffd5a54923bde9b70a40e8455495d45747a9a"></a>ETH_MQ_TX_VMDQ_ONLY&#160;</td><td class="fielddoc">
<p>Only VT on, no DCB </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ac1f701a3e5754496d2dff0063717bd88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#ac1f701a3e5754496d2dff0063717bd88">rte_fdir_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flow Director setting modes: none (default), signature or perfect. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ac1f701a3e5754496d2dff0063717bd88a49cef59325a47ce26833bc05a45575d6"></a>RTE_FDIR_MODE_NONE&#160;</td><td class="fielddoc">
<p>Disable FDIR support. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac1f701a3e5754496d2dff0063717bd88a999048853d885e0ebd9d6cb836a2e6bf"></a>RTE_FDIR_MODE_SIGNATURE&#160;</td><td class="fielddoc">
<p>Enable FDIR signature filter mode. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac1f701a3e5754496d2dff0063717bd88a52832673f79e3b7680f3233fe51065c7"></a>RTE_FDIR_MODE_PERFECT&#160;</td><td class="fielddoc">
<p>Enable FDIR perfect filter mode. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a9eda431989b68c708c7a875d71592a70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#a9eda431989b68c708c7a875d71592a70">rte_fdir_pballoc_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Memory space that can be configured to store Flow Director filters in the board memory. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a9eda431989b68c708c7a875d71592a70aeb67d5bf14d3e6c963eb627e8c8abc8e"></a>RTE_FDIR_PBALLOC_64K&#160;</td><td class="fielddoc">
<p>64k. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9eda431989b68c708c7a875d71592a70a4c095c272b86375f3b29c3ce23ca238d"></a>RTE_FDIR_PBALLOC_128K&#160;</td><td class="fielddoc">
<p>128k. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a9eda431989b68c708c7a875d71592a70ab9e7b2208dc797c9e913fb6b003f0548"></a>RTE_FDIR_PBALLOC_256K&#160;</td><td class="fielddoc">
<p>256k. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="acf7335105af297398262762ce692765b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#acf7335105af297398262762ce692765b">rte_fdir_status_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select report mode of FDIR hash information in RX descriptors. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="acf7335105af297398262762ce692765bac24f0fb424f6be0210378292be1add92"></a>RTE_FDIR_NO_REPORT_STATUS&#160;</td><td class="fielddoc">
<p>Never report FDIR hash. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acf7335105af297398262762ce692765bab49c02f6409e08d0dedae3d57ab17507"></a>RTE_FDIR_REPORT_STATUS&#160;</td><td class="fielddoc">
<p>Only report FDIR hash for matching pkts. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acf7335105af297398262762ce692765bad952da675964dab34452bb9efa07ad46"></a>RTE_FDIR_REPORT_STATUS_ALWAYS&#160;</td><td class="fielddoc">
<p>Always report FDIR hash. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ab3327734f777895234ece5ea5de0c780"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#ab3327734f777895234ece5ea5de0c780">rte_iptype</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select IPv4 or IPv6 FDIR filters. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ab3327734f777895234ece5ea5de0c780aebec00f336b0666124aa17ad435f4cf4"></a>RTE_FDIR_IPTYPE_IPV4&#160;</td><td class="fielddoc">
<p>IPv4. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab3327734f777895234ece5ea5de0c780abe40d851439cafc8416031dc11aaa635"></a>RTE_FDIR_IPTYPE_IPV6&#160;</td><td class="fielddoc">
<p>IPv6. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a438bfb53a537ee87e81104affb6a0712"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__ethdev_8h.html#a438bfb53a537ee87e81104affb6a0712">rte_l4type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possible l4type of FDIR filters. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a438bfb53a537ee87e81104affb6a0712afe1df6f7bd34e30c30f7194c17e0ba51"></a>RTE_FDIR_L4TYPE_NONE&#160;</td><td class="fielddoc">
<p>None. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a438bfb53a537ee87e81104affb6a0712acf8d433c8a6cac2f2f5297926a096edc"></a>RTE_FDIR_L4TYPE_UDP&#160;</td><td class="fielddoc">
<p>UDP. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a438bfb53a537ee87e81104affb6a0712a5ba555e38f0fb9a9af263102d4d7e3b3"></a>RTE_FDIR_L4TYPE_TCP&#160;</td><td class="fielddoc">
<p>TCP. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a438bfb53a537ee87e81104affb6a0712a92739d6622f4172deb1a9027322a66fc"></a>RTE_FDIR_L4TYPE_SCTP&#160;</td><td class="fielddoc">
<p>SCTP. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a249a40c851f6228c72e65867618e5f49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_eth_allmulticast_disable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable the receipt of all multicast frames by an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8432a0c27f9802ace08debf905f85d9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_eth_allmulticast_enable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable the receipt of any multicast frame by an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98ccfba7aea644ec8b64ed13957139aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_allmulticast_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of allmulticast mode for an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(1) if allmulticast is enabled</li>
<li>(0) if allmulticast is disabled.</li>
<li>(-1) on error </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af2dbe6cbeb42b005f0103f566d578094"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_add_2tuple_filter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__2tuple__filter.html">rte_2tuple_filter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rx_queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new 2tuple filter rule on an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">index</td><td>The identifier of 2tuple filter. </td></tr>
    <tr><td class="paramname">filter</td><td>The pointer to the structure describing the 2tuple filter rule. The <em><a class="el" href="structrte__2tuple__filter.html">rte_2tuple_filter</a></em> structure includes the values of the different fields to match: protocol, dst_port and tcp_flags if the protocol is tcp type. </td></tr>
    <tr><td class="paramname">rx_queue</td><td>The index of the RX queue where to store RX packets matching the added 2tuple filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support 2tuple filter.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if the filter information is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aaa28adafa65a4f47d4aeceaf1b08381b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_add_5tuple_filter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__5tuple__filter.html">rte_5tuple_filter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rx_queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new 5tuple filter rule on an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">index</td><td>The identifier of 5tuple filter. </td></tr>
    <tr><td class="paramname">filter</td><td>The pointer to the structure describing the 5tuple filter rule. The <em><a class="el" href="structrte__5tuple__filter.html">rte_5tuple_filter</a></em> structure includes the values of the different fields to match: dst src IP, dst src port, protocol and relative masks </td></tr>
    <tr><td class="paramname">rx_queue</td><td>The index of the RX queue where to store RX packets matching the added 5tuple filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support 5tuple filter.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if the filter information is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="acb0dceb40fbe1866728d7dc9b1984edc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_add_ethertype_filter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__ethertype__filter.html">rte_ethertype_filter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rx_queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new ethertype filter rule on an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">index</td><td>The identifier of ethertype filter. </td></tr>
    <tr><td class="paramname">filter</td><td>The pointer to the structure describing the ethertype filter rule. The <em><a class="el" href="structrte__ethertype__filter.html">rte_ethertype_filter</a></em> structure includes the values of the different fields to match: ethertype and priority in vlan tag. priority in vlan tag is not supported for E1000 dev. </td></tr>
    <tr><td class="paramname">rx_queue</td><td>The index of the RX queue where to store RX packets matching the added ethertype filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support ethertype filter.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if the filter information is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a6082f80ffda75e5f22a612d473bfbbd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_add_flex_filter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__flex__filter.html">rte_flex_filter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rx_queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new flex filter rule on an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">index</td><td>The identifier of flex filter. </td></tr>
    <tr><td class="paramname">filter</td><td>The pointer to the structure describing the flex filter rule. The <em><a class="el" href="structrte__flex__filter.html">rte_flex_filter</a></em> structure includes the values of the different fields to match: the dwords (first len bytes of packet ) and relative masks. </td></tr>
    <tr><td class="paramname">rx_queue</td><td>The index of the RX queue where to store RX packets matching the added flex filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support flex filter.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if the filter information is not correct.</li>
<li>(-ENOENT) if no enabled filter in this index. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a21729867669488dc2f22d923a856a966"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_add_syn_filter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__syn__filter.html">rte_syn_filter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rx_queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>add syn filter</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">rx_queue</td><td>The index of RX queue where to store RX packets matching the syn filter. </td></tr>
    <tr><td class="paramname">filter</td><td>The pointer to the structure describing the syn filter rule. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af20aa121231e3e0a9e705619ebf84983"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct rte_eth_dev* rte_eth_dev_allocate </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function for internal use by dummy drivers primarily, e.g. ring-based driver. Allocates a new ethdev slot for an ethernet device and returns the pointer to that slot for the driver to use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Unique identifier name for each Ethernet device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>Slot in the rte_dev_devices array for a new device; </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab067ba3ed3c3e663ec0e2e45721baa73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_bypass_event_show </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return bypass state when given event occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">event</td><td>The bypass event<ul>
<li>(1) Main power on (power button is pushed)</li>
<li>(2) Auxiliary power on (power supply is being plugged)</li>
<li>(3) Main power off (system shutdown and power supply is left plugged in)</li>
<li>(4) Auxiliary power off (power supply is being unplugged)</li>
<li>(5) Display or set the watchdog timer </li>
</ul>
</td></tr>
    <tr><td class="paramname">state</td><td>The bypass state when given event occurred.<ul>
<li>(1) Normal mode</li>
<li>(2) Bypass mode</li>
<li>(3) Isolate mode </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="afde602eff86b7574cbd961ee1b41ee7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_bypass_event_store </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set bypass state when given event occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">event</td><td>The bypass event<ul>
<li>(1) Main power on (power button is pushed)</li>
<li>(2) Auxiliary power on (power supply is being plugged)</li>
<li>(3) Main power off (system shutdown and power supply is left plugged in)</li>
<li>(4) Auxiliary power off (power supply is being unplugged)</li>
<li>(5) Display or set the watchdog timer </li>
</ul>
</td></tr>
    <tr><td class="paramname">state</td><td>The assigned state when given event occurs.<ul>
<li>(1) Normal mode</li>
<li>(2) Bypass mode</li>
<li>(3) Isolate mode </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a65c1155e6337a225bb25f09b445ff5f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_bypass_init </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize bypass logic. This function needs to be called before executing any other bypass API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af2094bade4ba6174124a5a3b56991833"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_bypass_state_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>new_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set bypass state</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">state</td><td>The current bypass state.<ul>
<li>(1) Normal mode</li>
<li>(2) Bypass mode</li>
<li>(3) Isolate mode </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad3e74e4854876fbc91ee6c3f164b2e13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_bypass_state_show </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return bypass state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">state</td><td>The return bypass state.<ul>
<li>(1) Normal mode</li>
<li>(2) Bypass mode</li>
<li>(3) Isolate mode </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a11c874ce7b7411063749681bdae7b976"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_bypass_ver_show </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get bypass firmware version.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">ver</td><td>The firmware version </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab1bdf2f73208a71e3184e7110dd772ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_bypass_wd_reset </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset bypass watchdog timer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a92494342ed7227bd54a9d13a9a96ccf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_bypass_wd_timeout_show </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>wd_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return bypass watchdog timeout in seconds</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">wd_timeout</td><td>The return watchdog timeout. "0" represents timer expired<ul>
<li>(0) 0 seconds (timer is off)</li>
<li>(1) 1.5 seconds</li>
<li>(2) 2 seconds</li>
<li>(3) 3 seconds</li>
<li>(4) 4 seconds</li>
<li>(5) 8 seconds</li>
<li>(6) 16 seconds</li>
<li>(7) 32 seconds </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a9f1527b4d69614354984ae65fc72362b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_callback_register </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779d">rte_eth_event_type</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__ethdev_8h.html#a26f17da8528d43edd6810815530ee954">rte_eth_dev_cb_fn</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a callback function for specific port id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>Port id. </td></tr>
    <tr><td class="paramname">event</td><td>Event interested. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>User supplied callback function to be called. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Pointer to the parameters for the registered callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, zero.</li>
<li>On failure, a negative value. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af56829d8b02096b6a55bed7b5038aaad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_callback_unregister </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__ethdev_8h.html#a1e6788469a92700a583d06bf079d779d">rte_eth_event_type</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__ethdev_8h.html#a26f17da8528d43edd6810815530ee954">rte_eth_dev_cb_fn</a>&#160;</td>
          <td class="paramname"><em>cb_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cb_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for specific port id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>Port id. </td></tr>
    <tr><td class="paramname">event</td><td>Event interested. </td></tr>
    <tr><td class="paramname">cb_fn</td><td>User supplied callback function to be called. </td></tr>
    <tr><td class="paramname">cb_arg</td><td>Pointer to the parameters for the registered callback. -1 means to remove all for the same callback address and same event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>On success, zero.</li>
<li>On failure, a negative value. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af8f303682c9ee2aa48d58ffd812d842d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_eth_dev_close </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close an Ethernet device. The device cannot be restarted!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac30d075b4b206c7122e200164ce69893"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_configure </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_rx_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_tx_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__eth__conf.html">rte_eth_conf</a> *&#160;</td>
          <td class="paramname"><em>eth_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure an Ethernet device. This function must be invoked first before any other function in the Ethernet API. This function can also be re-invoked when a device is in the stopped state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device to configure. </td></tr>
    <tr><td class="paramname">nb_rx_queue</td><td>The number of receive queues to set up for the Ethernet device. </td></tr>
    <tr><td class="paramname">nb_tx_queue</td><td>The number of transmit queues to set up for the Ethernet device. </td></tr>
    <tr><td class="paramname">eth_conf</td><td>The pointer to the configuration data to be used for the Ethernet device. The <em><a class="el" href="structrte__eth__conf.html">rte_eth_conf</a></em> structure includes:<ul>
<li>the hardware offload features to activate, with dedicated fields for each statically configurable offload hardware feature provided by Ethernet devices, such as IP checksum or VLAN tag stripping for example.</li>
<li>the Receive Side Scaling (RSS) configuration when using multiple RX queues per port.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>Embedding all configuration information in a single data structure is the more flexible method that allows the addition of new features without changing the syntax of the API. </p><dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, device configured.</li>
<li>&lt;0: Error code returned by the driver configuration function. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ac228551f31e57645c7bb5efd1db2e63d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rte_eth_dev_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the total number of Ethernet devices that have been successfully initialized by the [matching] Ethernet driver during the PCI probing phase. All devices whose port identifier is in the range [0, <a class="el" href="rte__ethdev_8h.html#ac228551f31e57645c7bb5efd1db2e63d">rte_eth_dev_count()</a> - 1] can be operated on by network applications.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The total number of usable Ethernet devices. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a4b5782c072f8daebd23a7a048d9b21fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_fdir_add_perfect_filter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__fdir__filter.html">rte_fdir_filter</a> *&#160;</td>
          <td class="paramname"><em>fdir_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>soft_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rx_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new perfect filter rule on an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">fdir_filter</td><td>The pointer to the structure describing the perfect filter rule. The <em><a class="el" href="structrte__fdir__filter.html">rte_fdir_filter</a></em> structure includes the values of the different fields to match: source and destination IP addresses, vlan id, flexbytes, source and destination ports, and so on. IPv6 are not supported. </td></tr>
    <tr><td class="paramname">soft_id</td><td>The 16-bit value supplied in the field hash.fdir.id of mbuf for RX packets matching the perfect filter. </td></tr>
    <tr><td class="paramname">rx_queue</td><td>The index of the RX queue where to store RX packets matching the added perfect filter defined in fdir_filter. </td></tr>
    <tr><td class="paramname">drop</td><td>If drop is set to 1, matching RX packets are stored into the RX drop queue defined in the <a class="el" href="structrte__fdir__conf.html">rte_fdir_conf</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support flow director mode.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-ENOSYS) if the flow director mode is not configured in perfect mode on <em>port_id</em>.</li>
<li>(-EINVAL) if the fdir_filter information is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a4ef515ffe18b57bed5493bcea90f16d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_fdir_add_signature_filter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__fdir__filter.html">rte_fdir_filter</a> *&#160;</td>
          <td class="paramname"><em>fdir_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rx_queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Setup a new signature filter rule on an Ethernet device</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">fdir_filter</td><td>The pointer to the fdir filter structure describing the signature filter rule. The <em><a class="el" href="structrte__fdir__filter.html">rte_fdir_filter</a></em> structure includes the values of the different fields to match: source and destination IP addresses, vlan id, flexbytes, source and destination ports, and so on. </td></tr>
    <tr><td class="paramname">rx_queue</td><td>The index of the RX queue where to store RX packets matching the added signature filter defined in fdir_filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support flow director mode.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-ENOSYS) if the FDIR mode is not configured in signature mode on <em>port_id</em>.</li>
<li>(-EINVAL) if the fdir_filter information is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a546527cc9b28e1a37a4e0be5f951243e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_fdir_get_infos </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__fdir.html">rte_eth_fdir</a> *&#160;</td>
          <td class="paramname"><em>fdir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the flow director information of an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">fdir</td><td>A pointer to a structure of type <em>rte_eth_dev_fdir</em> to be filled with the flow director information of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support flow director mode.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-ENOSYS) if the flow director mode is not configured on <em>port_id</em>. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aae57f0c90e84bf440e0499dd17ab8252"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_fdir_remove_perfect_filter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__fdir__filter.html">rte_fdir_filter</a> *&#160;</td>
          <td class="paramname"><em>fdir_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>soft_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a perfect filter rule on an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">fdir_filter</td><td>The pointer to the structure describing the perfect filter rule. The <em><a class="el" href="structrte__fdir__filter.html">rte_fdir_filter</a></em> structure includes the values of the different fields to match: source and destination IP addresses, vlan id, flexbytes, source and destination ports, and so on. IPv6 are not supported. </td></tr>
    <tr><td class="paramname">soft_id</td><td>The soft_id value provided when adding/updating the removed filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support flow director mode.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-ENOSYS) if the flow director mode is not configured in perfect mode on <em>port_id</em>.</li>
<li>(-EINVAL) if the fdir_filter information is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad3fdd145f92f7195411165dcb25e4ff9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_fdir_remove_signature_filter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__fdir__filter.html">rte_fdir_filter</a> *&#160;</td>
          <td class="paramname"><em>fdir_ftr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a signature filter rule on an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">fdir_ftr</td><td>The pointer to the structure describing the signature filter rule. The <em><a class="el" href="structrte__fdir__filter.html">rte_fdir_filter</a></em> structure includes the values of the different fields to match: source and destination IP addresses, vlan id, flexbytes, source and destination ports, and so on. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support flow director mode.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-ENOSYS) if the flow director mode is not configured in signature mode on <em>port_id</em>.</li>
<li>(-EINVAL) if the fdir_filter information is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab99d956b16278a9fd05e9068f04031ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_fdir_set_masks </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__fdir__masks.html">rte_fdir_masks</a> *&#160;</td>
          <td class="paramname"><em>fdir_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure globally the masks for flow director mode for an Ethernet device. For example, the device can match packets with only the first 24 bits of the IPv4 source address.</p>
<p>The following fields can be masked: IPv4 addresses and L4 port numbers. The following fields can be either enabled or disabled completely for the matching functionality: VLAN ID tag; VLAN Priority + CFI bit; Flexible 2-byte tuple. IPv6 masks are not supported.</p>
<p>All filters must comply with the masks previously configured. For example, with a mask equal to 255.255.255.0 for the source IPv4 address, all IPv4 filters must be created with a source IPv4 address that fits the "X.X.X.0" format.</p>
<p>This function flushes all filters that have been previously added in the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">fdir_mask</td><td>The pointer to the fdir mask structure describing relevant headers fields and relevant bits to use when matching packets addresses and ports. IPv6 masks are not supported. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support flow director mode.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-ENOSYS) if the flow director mode is not configured in perfect mode on <em>port_id</em>.</li>
<li>(-EINVAL) if the fdir_filter information is not correct </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a025b75c743312a2ca328bb4f3c6e5df1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_fdir_update_perfect_filter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__fdir__filter.html">rte_fdir_filter</a> *&#160;</td>
          <td class="paramname"><em>fdir_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>soft_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rx_queue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update a perfect filter rule on an Ethernet device. If the rule doesn't exits, it is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">fdir_filter</td><td>The pointer to the structure describing the perfect filter rule. The <em><a class="el" href="structrte__fdir__filter.html">rte_fdir_filter</a></em> structure includes the values of the different fields to match: source and destination IP addresses, vlan id, flexbytes, source and destination ports, and so on. IPv6 are not supported. </td></tr>
    <tr><td class="paramname">soft_id</td><td>The 16-bit value supplied in the field hash.fdir.id of mbuf for RX packets matching the perfect filter. </td></tr>
    <tr><td class="paramname">rx_queue</td><td>The index of the RX queue where to store RX packets matching the added perfect filter defined in fdir_filter. </td></tr>
    <tr><td class="paramname">drop</td><td>If drop is set to 1, matching RX packets are stored into the RX drop queue defined in the <a class="el" href="structrte__fdir__conf.html">rte_fdir_conf</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support flow director mode.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-ENOSYS) if the flow director mode is not configured in perfect mode on <em>port_id</em>.</li>
<li>(-EINVAL) if the fdir_filter information is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae13340acf9108d1ef878ab82e3c53a22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_fdir_update_signature_filter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__fdir__filter.html">rte_fdir_filter</a> *&#160;</td>
          <td class="paramname"><em>fdir_ftr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rx_queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update a signature filter rule on an Ethernet device. If the rule doesn't exits, it is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">fdir_ftr</td><td>The pointer to the structure describing the signature filter rule. The <em><a class="el" href="structrte__fdir__filter.html">rte_fdir_filter</a></em> structure includes the values of the different fields to match: source and destination IP addresses, vlan id, flexbytes, source and destination ports, and so on. </td></tr>
    <tr><td class="paramname">rx_queue</td><td>The index of the RX queue where to store RX packets matching the added signature filter defined in fdir_ftr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support flow director mode.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-ENOSYS) if the flow director mode is not configured in signature mode on <em>port_id</em>.</li>
<li>(-EINVAL) if the fdir_filter information is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a42ae9db8ce587e2391fe73aa8e9878f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_flow_ctrl_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__fc__conf.html">rte_eth_fc_conf</a> *&#160;</td>
          <td class="paramname"><em>fc_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get current status of the Ethernet link flow control for Ethernet device</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">fc_conf</td><td>The pointer to the structure where to store the flow control parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support flow control.</li>
<li>(-ENODEV) if <em>port_id</em> invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab55335f4dbf971dddc9dbbbdad08e491"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_flow_ctrl_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__fc__conf.html">rte_eth_fc_conf</a> *&#160;</td>
          <td class="paramname"><em>fc_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure the Ethernet link flow control for Ethernet device</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">fc_conf</td><td>The pointer to the structure of the flow control parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support flow control mode.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter</li>
<li>(-EIO) if flow control setup failure </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1ebb7d5ecf1468b8c8a3fe5c3f5c2ba3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_get_2tuple_filter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__2tuple__filter.html">rte_2tuple_filter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>rx_queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an 2tuple filter rule on an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">index</td><td>The identifier of 2tuple filter. </td></tr>
    <tr><td class="paramname">filter</td><td>A pointer to a structure of type <em><a class="el" href="structrte__2tuple__filter.html">rte_2tuple_filter</a></em> to be filled with the information of the 2tuple filter. </td></tr>
    <tr><td class="paramname">rx_queue</td><td>A pointer to get the queue index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support 2tuple filter.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if the filter information is not correct.</li>
<li>(-ENOENT) if no enabled filter in this index. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae14a8e975984710a983586220f91500d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_get_5tuple_filter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__5tuple__filter.html">rte_5tuple_filter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>rx_queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an 5tuple filter rule on an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">index</td><td>The identifier of 5tuple filter. </td></tr>
    <tr><td class="paramname">filter</td><td>A pointer to a structure of type <em><a class="el" href="structrte__5tuple__filter.html">rte_5tuple_filter</a></em> to be filled with the information of the 5tuple filter. </td></tr>
    <tr><td class="paramname">rx_queue</td><td>A pointer to get the queue index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support 5tuple filter.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if the filter information is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a6ea554d71fc2edf3eb00200c74e63603"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_get_ethertype_filter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__ethertype__filter.html">rte_ethertype_filter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>rx_queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an ethertype filter rule on an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">index</td><td>The identifier of ethertype filter. </td></tr>
    <tr><td class="paramname">filter</td><td>A pointer to a structure of type <em><a class="el" href="structrte__ethertype__filter.html">rte_ethertype_filter</a></em> to be filled with the information of the Ethertype filter. </td></tr>
    <tr><td class="paramname">rx_queue</td><td>A pointer to get the queue index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support ethertype filter.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if the filter information is not correct.</li>
<li>(-ENOENT) if no enabled filter in this index. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a135b7836dd15a5273e1657269a7e73b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_get_flex_filter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__flex__filter.html">rte_flex_filter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>rx_queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an flex filter rule on an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">index</td><td>The identifier of flex filter. </td></tr>
    <tr><td class="paramname">filter</td><td>A pointer to a structure of type <em><a class="el" href="structrte__flex__filter.html">rte_flex_filter</a></em> to be filled with the information of the flex filter. </td></tr>
    <tr><td class="paramname">rx_queue</td><td>A pointer to get the queue index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support flex filter.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if the filter information is not correct.</li>
<li>(-ENOENT) if no enabled filter in this index. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a89b91165080d12c057cb82c7f38a0d44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_get_mtu </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>mtu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the MTU of an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">mtu</td><td>A pointer to a uint16_t where the retrieved MTU is to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENODEV) if <em>port_id</em> invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8edffbdf8ae12681211230535f711992"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_get_syn_filter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__syn__filter.html">rte_syn_filter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>rx_queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>get syn filter</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">filter</td><td>The pointer to the structure describing the syn filter. </td></tr>
    <tr><td class="paramname">rx_queue</td><td>A pointer to get the queue index of syn filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae94784b4dde62cbbeedc3b3bed14dc1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_get_vlan_offload </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read VLAN Offload configuration from an Ethernet device</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(&gt;0) if successful. Bit mask to indicate ETH_VLAN_STRIP_OFFLOAD ETH_VLAN_FILTER_OFFLOAD ETH_VLAN_EXTEND_OFFLOAD</li>
<li>(-ENODEV) if <em>port_id</em> invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a469a98f6245c85d14f58af8f73168d8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_eth_dev_info_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct rte_eth_dev_info *&#160;</td>
          <td class="paramname"><em>dev_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the contextual information of an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">dev_info</td><td>A pointer to a structure of type <em>rte_eth_dev_info</em> to be filled with the contextual information of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa2b81750086f5f9e55cf65e5cf9f2c58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_mac_addr_add </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structether__addr.html">ether_addr</a> *&#160;</td>
          <td class="paramname"><em>mac_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a MAC address to an internal array of addresses used to enable whitelist filtering to accept packets only if the destination MAC address matches.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">mac_addr</td><td>The MAC address to add. </td></tr>
    <tr><td class="paramname">pool</td><td>VMDq pool index to associate address with (if VMDq is enabled). If VMDq is not enabled, this should be set to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successfully added or <em>mac_addr" was already added.</em></li>
<li><em>(-ENOTSUP) if hardware doesn't support this feature.</em></li>
<li><em>(-ENODEV) if *port</em> is invalid.</li>
<li>(-ENOSPC) if no more MAC addresses can be added.</li>
<li>(-EINVAL) if MAC address is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad6dce3e24e3443c64da7f5ace3ddf36b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_mac_addr_remove </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structether__addr.html">ether_addr</a> *&#160;</td>
          <td class="paramname"><em>mac_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a MAC address from the internal array of addresses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">mac_addr</td><td>MAC address to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful, or <em>mac_addr</em> didn't exist.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-ENODEV) if <em>port</em> invalid.</li>
<li>(-EADDRINUSE) if attempting to remove the default MAC address </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a03eb9093c037eb9ea96f8e6551e71ea5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_priority_flow_ctrl_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__pfc__conf.html">rte_eth_pfc_conf</a> *&#160;</td>
          <td class="paramname"><em>pfc_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configure the Ethernet priority flow control under DCB environment for Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">pfc_conf</td><td>The pointer to the structure of the priority flow control parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support priority flow control mode.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter</li>
<li>(-EIO) if flow control setup failure </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aefcfa984fc0d74cc64867f62a9588d5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_remove_2tuple_filter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>remove a 2tuple filter rule on an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">index</td><td>The identifier of 2tuple filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support 2tuple filter.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if the filter information is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="acc0f7d77dd40c342f2d06f6fbe763d62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_remove_5tuple_filter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>remove a 5tuple filter rule on an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">index</td><td>The identifier of 5tuple filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support 5tuple filter.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if the filter information is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a86b7eac06b4a7e58f330bf719969abe3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_remove_ethertype_filter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>remove an ethertype filter rule on an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">index</td><td>The identifier of ethertype filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support ethertype filter.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if the filter information is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af9893d23d25a911fbdc5b5adac8c4c46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_remove_flex_filter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>remove a flex filter rule on an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">index</td><td>The identifier of flex filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support flex filter.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if the filter information is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af000f142f2cd529df2afdae5f2af0f47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_remove_syn_filter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>remove syn filter</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a65ab8e6bf1417381440d51f49bffafc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_rss_hash_conf_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__rss__conf.html">rte_eth_rss_conf</a> *&#160;</td>
          <td class="paramname"><em>rss_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve current configuration of Receive Side Scaling hash computation of Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">rss_conf</td><td>Where to store the current RSS hash configuration of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENODEV) if port identifier is invalid.</li>
<li>(-ENOTSUP) if hardware doesn't support RSS. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ac6444b5ab7f425c7ccb02a980cecce52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_rss_hash_update </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__rss__conf.html">rte_eth_rss_conf</a> *&#160;</td>
          <td class="paramname"><em>rss_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configuration of Receive Side Scaling hash computation of Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">rss_conf</td><td>The new configuration to use for RSS hash computation on the port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENODEV) if port identifier is invalid.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ac80e7b9b2ec61bd9ac760da4b5d09e77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_rss_reta_query </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__rss__reta.html">rte_eth_rss_reta</a> *&#160;</td>
          <td class="paramname"><em>reta_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query Redirection Table(RETA) of Receive Side Scaling of Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">reta_conf</td><td>RETA to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa851e1a7beae2bdbd80e4194fdcf6558"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_rss_reta_update </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__rss__reta.html">rte_eth_rss_reta</a> *&#160;</td>
          <td class="paramname"><em>reta_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update Redirection Table(RETA) of Receive Side Scaling of Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">reta_conf</td><td>RETA to update. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1fd9012303eae348ada932a671b752bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_link_down </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Link down an Ethernet device. The device rx/tx functionality will be disabled if success, and it can be re-enabled with a call to <a class="el" href="rte__ethdev_8h.html#ad29198523ea850aa2045bc8654f62574">rte_eth_dev_set_link_up()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad29198523ea850aa2045bc8654f62574"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_link_up </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Link up an Ethernet device.</p>
<p>Set device link up will re-enable the device rx/tx functionality after it is previously set device linked down.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, Ethernet device linked up.</li>
<li>&lt;0: Error code of the driver device link up function. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab1f4a53ed758fe04a9e4f554a4d500e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_mtu </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>mtu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the MTU of an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">mtu</td><td>A uint16_t for the MTU to be applied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if operation is not supported.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if <em>mtu</em> invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad7ea35870991fb68a574d69fc74d186a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_rx_queue_stats_mapping </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rx_queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>stat_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a mapping for the specified receive queue to the specified per-queue statistics counter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">rx_queue_id</td><td>The index of the receive queue for which a queue stats mapping is required. The value must be in the range [0, nb_rx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#ac30d075b4b206c7122e200164ce69893">rte_eth_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">stat_idx</td><td>The per-queue packet statistics functionality number that the receive queue is to be assigned. The value must be in the range [0, RTE_MAX_ETHPORT_QUEUE_STATS_MAPS - 1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if successful. Non-zero otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3fb6267902e47293ef419cb44dd1d54c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_tx_queue_stats_mapping </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tx_queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>stat_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a mapping for the specified transmit queue to the specified per-queue statistics counter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">tx_queue_id</td><td>The index of the transmit queue for which a queue stats mapping is required. The value must be in the range [0, nb_tx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#ac30d075b4b206c7122e200164ce69893">rte_eth_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">stat_idx</td><td>The per-queue packet statistics functionality number that the transmit queue is to be assigned. The value must be in the range [0, RTE_MAX_ETHPORT_QUEUE_STATS_MAPS - 1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if successful. Non-zero otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad02ac76da48829829a067d2f2ab3d59b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_vf_rx </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>vf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable a VF traffic receive of an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">vf</td><td>VF id. </td></tr>
    <tr><td class="paramname">on</td><td>1 - Enable a VF traffic receive. 0 - Disable a VF traffic receive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0a19a56a4540b023b5d6ddb759f79d37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_vf_rxmode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>vf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rx_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set RX L2 Filtering mode of a VF of an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">vf</td><td>VF id. </td></tr>
    <tr><td class="paramname">rx_mode</td><td>The RX mode mask, which is one or more of accepting Untagged Packets, packets that match the PFUTA table, Broadcast and Multicast Promiscuous. ETH_VMDQ_ACCEPT_UNTAG,ETH_VMDQ_ACCEPT_HASH_UC, ETH_VMDQ_ACCEPT_BROADCAST and ETH_VMDQ_ACCEPT_MULTICAST will be used in rx_mode. </td></tr>
    <tr><td class="paramname">on</td><td>1 - Enable a VF RX mode. 0 - Disable a VF RX mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a267488519b53e4eea68fa23347d31c0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_vf_tx </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>vf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable a VF traffic transmit of the Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">vf</td><td>VF id. </td></tr>
    <tr><td class="paramname">on</td><td>1 - Enable a VF traffic transmit. 0 - Disable a VF traffic transmit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8d04b22971d05ea8c7db12342b1333a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_vf_vlan_filter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>vlan_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>vf_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>vlan_on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable/Disable hardware VF VLAN filtering by an Ethernet device of received VLAN packets tagged with a given VLAN Tag Identifier.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>id The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">vlan_id</td><td>The VLAN Tag Identifier whose filtering must be enabled or disabled. </td></tr>
    <tr><td class="paramname">vf_mask</td><td>Bitmap listing which VFs participate in the VLAN filtering. </td></tr>
    <tr><td class="paramname">vlan_on</td><td>1 - Enable VFs VLAN filtering. 0 - Disable VFs VLAN filtering. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="adf909eed7c681230644ea0ec2ad5ef6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_vlan_ether_type </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tag_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the Outer VLAN Ether Type by an Ethernet device, it can be inserted to the VLAN Header. This is a register setup available on some Intel NIC, not but all, please check the data sheet for availability.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">tag_type</td><td>The Tag Protocol ID </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOSUP) if hardware-assisted VLAN TPID setup is not supported.</li>
<li>(-ENODEV) if <em>port_id</em> invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad5de5f589820b7b65b8197150cb2feaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_vlan_offload </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offload_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set VLAN offload configuration on an Ethernet device Enable/Disable Extended VLAN by an Ethernet device, This is a register setup available on some Intel NIC, not but all, please check the data sheet for availability. Enable/Disable VLAN Strip can be done on rx queue for certain NIC, but here the configuration is applied on the port level.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">offload_mask</td><td>The VLAN Offload bit mask can be mixed use with "OR" ETH_VLAN_STRIP_OFFLOAD ETH_VLAN_FILTER_OFFLOAD ETH_VLAN_EXTEND_OFFLOAD </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOSUP) if hardware-assisted VLAN filtering not configured.</li>
<li>(-ENODEV) if <em>port_id</em> invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="afde16bf1f8ff2d660678f597c6fd4896"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_vlan_pvid </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pvid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set port based TX VLAN insersion on or off.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">pvid</td><td>Port based TX VLAN identifier togeth with user priority. </td></tr>
    <tr><td class="paramname">on</td><td>Turn on or off the port based TX VLAN insertion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>negative if failed. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a15fd035ce805444a3df4738a5c53fa62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_set_vlan_strip_on_queue </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rx_queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable/Disable hardware VLAN Strip by a rx queue of an Ethernet device. 82599/X540 can support VLAN stripping at the rx queue level</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">rx_queue_id</td><td>The index of the receive queue for which a queue stats mapping is required. The value must be in the range [0, nb_rx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#ac30d075b4b206c7122e200164ce69893">rte_eth_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">on</td><td>If 1, Enable VLAN Stripping of the receive queue of the Ethernet port. If 0, Disable VLAN Stripping of the receive queue of the Ethernet port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOSUP) if hardware-assisted VLAN stripping not configured.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if <em>rx_queue_id</em> invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab6cdec593efa6b9809e711ade3a2fe24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_start </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an Ethernet device.</p>
<p>The device start step is the last one and consists of setting the configured offload features and in starting the transmit and the receive units of the device. On success, all basic functions exported by the Ethernet API (link status, receive/transmit, and so on) can be invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, Ethernet device started.</li>
<li>&lt;0: Error code of the driver device start function. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a322fa275f154022db7bce02ee95e5612"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_eth_dev_stop </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop an Ethernet device. The device can be restarted with a call to <a class="el" href="rte__ethdev_8h.html#ab6cdec593efa6b9809e711ade3a2fe24">rte_eth_dev_start()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeebec36d812fa2f8fb26ebcfc6697ff4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_uc_all_hash_table_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates all unicast hash bitmaps for receiving packet with any Unicast Ethernet MAC addresses,the packet is routed to all VFs for which the RX mode is accept packets that match the unicast hash table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">on</td><td>1 - Set all unicast hash bitmaps for receiving all the Ethernet MAC addresses 0 - Clear all unicast hash bitmaps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a309791aea821c7024dd6922ddf0cc4af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_uc_hash_table_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structether__addr.html">ether_addr</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates unicast hash table for receiving packet with the given destination MAC address, and the packet is routed to all VFs for which the RX mode is accept packets that match the unicast hash table.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">addr</td><td>Unicast MAC address. </td></tr>
    <tr><td class="paramname">on</td><td>1 - Set an unicast hash bit for receiving packets with the MAC address. 0 - Clear an unicast hash bit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a76b4af0fa671325b33ce8841b96ae997"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_vlan_filter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>vlan_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable/Disable hardware filtering by an Ethernet device of received VLAN packets tagged with a given VLAN Tag Identifier.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">vlan_id</td><td>The VLAN Tag Identifier whose filtering must be enabled or disabled. </td></tr>
    <tr><td class="paramname">on</td><td>If &gt; 0, enable VLAN filtering of VLAN packets tagged with <em>vlan_id</em>. Otherwise, disable VLAN filtering of VLAN packets tagged with <em>vlan_id</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOSUP) if hardware-assisted VLAN filtering not configured.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-ENOSYS) if VLAN filtering on <em>port_id</em> disabled.</li>
<li>(-EINVAL) if <em>vlan_id</em> &gt; 4095. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ac114558859d52cf2117e93efe6ab0630"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_dev_wd_timeout_store </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set bypass watchdog timeout count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">state</td><td>The timeout to be set.<ul>
<li>(0) 0 seconds (timer is off)</li>
<li>(1) 1.5 seconds</li>
<li>(2) 2 seconds</li>
<li>(3) 3 seconds</li>
<li>(4) 4 seconds</li>
<li>(5) 8 seconds</li>
<li>(6) 16 seconds</li>
<li>(7) 32 seconds </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ac00483521d3e5274d2976a78525d507e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_led_off </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Turn off the LED on the Ethernet device. This function turns off the LED on the Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if underlying hardware OR driver doesn't support that operation.</li>
<li>(-ENODEV) if <em>port_id</em> invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ac7098a4ca8bc507c3064719ba96be8f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_led_on </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Turn on the LED on the Ethernet device. This function turns on the LED on the Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if underlying hardware OR driver doesn't support that operation.</li>
<li>(-ENODEV) if <em>port_id</em> invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1ceaee11c58efd9c12ef7d2f99f87445"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_eth_link_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__link.html">rte_eth_link</a> *&#160;</td>
          <td class="paramname"><em>link</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the status (ON/OFF), the speed (in Mbps) and the mode (HALF-DUPLEX or FULL-DUPLEX) of the physical link of an Ethernet device. It might need to wait up to 9 seconds in it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">link</td><td>A pointer to an <em><a class="el" href="structrte__eth__link.html">rte_eth_link</a></em> structure to be filled with the status, the speed and the mode of the Ethernet device link. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6908b1ef94c95ef85af851e6705a5f93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_eth_link_get_nowait </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__link.html">rte_eth_link</a> *&#160;</td>
          <td class="paramname"><em>link</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the status (ON/OFF), the speed (in Mbps) and the mode (HALF-DUPLEX or FULL-DUPLEX) of the physical link of an Ethernet device. It is a no-wait version of <a class="el" href="rte__ethdev_8h.html#a1ceaee11c58efd9c12ef7d2f99f87445">rte_eth_link_get()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">link</td><td>A pointer to an <em><a class="el" href="structrte__eth__link.html">rte_eth_link</a></em> structure to be filled with the status, the speed and the mode of the Ethernet device link. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5686df2817980236f2c4f1cc72dd2c30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_eth_macaddr_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structether__addr.html">ether_addr</a> *&#160;</td>
          <td class="paramname"><em>mac_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the Ethernet address of an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">mac_addr</td><td>A pointer to a structure of type <em><a class="el" href="structether__addr.html">ether_addr</a></em> to be filled with the Ethernet address of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6cca95dda28adc353f571499b9e027f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_mirror_rule_reset </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rule_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset a traffic mirroring rule on an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">rule_id</td><td>The index of traffic mirroring rule, we support four separated rules. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support this feature.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a71d674fb5acf9b35269713e49c4e5977"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_mirror_rule_set </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__vmdq__mirror__conf.html">rte_eth_vmdq_mirror_conf</a> *&#160;</td>
          <td class="paramname"><em>mirror_conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rule_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a traffic mirroring rule on an Ethernet device</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">mirror_conf</td><td>The pointer to the traffic mirroring structure describing the mirroring rule. The <em>rte_eth_vm_mirror_conf</em> structure includes the type of mirroring rule, destination pool and the value of rule if enable vlan or pool mirroring.</td></tr>
    <tr><td class="paramname">rule_id</td><td>The index of traffic mirroring rule, we support four separated rules. </td></tr>
    <tr><td class="paramname">on</td><td>1 - Enable a mirroring rule. 0 - Disable a mirroring rule. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support this feature.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if the mr_conf information is not correct. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af115d34c99a974996a9b70bdee86a58b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_eth_promiscuous_disable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable receipt in promiscuous mode for an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa8064b25aee324bdbbf779ea23d55f49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_eth_promiscuous_enable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable receipt in promiscuous mode for an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3569838a05625c5dbbaaad74872fcfd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_promiscuous_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of promiscuous mode for an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(1) if promiscuous is enabled</li>
<li>(0) if promiscuous is disabled.</li>
<li>(-1) on error </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a5ac93faa0f3f69545ca121dcfd9433f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_eth_rx_burst </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **&#160;</td>
          <td class="paramname"><em>rx_pkts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_pkts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve a burst of input packets from a receive queue of an Ethernet device. The retrieved packets are stored in <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> structures whose pointers are supplied in the <em>rx_pkts</em> array.</p>
<p>The <a class="el" href="rte__ethdev_8h.html#a5ac93faa0f3f69545ca121dcfd9433f5">rte_eth_rx_burst()</a> function loops, parsing the RX ring of the receive queue, up to <em>nb_pkts</em> packets, and for each completed RX descriptor in the ring, it performs the following operations:</p>
<ul>
<li>Initialize the <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> data structure associated with the RX descriptor according to the information provided by the NIC into that RX descriptor.</li>
<li>Store the <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> data structure into the next entry of the <em>rx_pkts</em> array.</li>
<li>Replenish the RX descriptor with a new <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> buffer allocated from the memory pool associated with the receive queue at initialization time.</li>
</ul>
<p>When retrieving an input packet that was scattered by the controller into multiple receive descriptors, the <a class="el" href="rte__ethdev_8h.html#a5ac93faa0f3f69545ca121dcfd9433f5">rte_eth_rx_burst()</a> function appends the associated <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> buffers to the first buffer of the packet.</p>
<p>The <a class="el" href="rte__ethdev_8h.html#a5ac93faa0f3f69545ca121dcfd9433f5">rte_eth_rx_burst()</a> function returns the number of packets actually retrieved, which is the number of <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> data structures effectively supplied into the <em>rx_pkts</em> array. A return value equal to <em>nb_pkts</em> indicates that the RX queue contained at least <em>rx_pkts</em> packets, and this is likely to signify that other received packets remain in the input queue. Applications implementing a "retrieve as much received packets as possible" policy can check this specific case and keep invoking the <a class="el" href="rte__ethdev_8h.html#a5ac93faa0f3f69545ca121dcfd9433f5">rte_eth_rx_burst()</a> function until a value less than <em>nb_pkts</em> is returned.</p>
<p>This receive method has the following advantages:</p>
<ul>
<li>It allows a run-to-completion network stack engine to retrieve and to immediately process received packets in a fast burst-oriented approach, avoiding the overhead of unnecessary intermediate packet queue/dequeue operations.</li>
<li>Conversely, it also allows an asynchronous-oriented processing method to retrieve bursts of received packets and to immediately queue them for further parallel processing by another logical core, for instance. However, instead of having received packets being individually queued by the driver, this approach allows the invoker of the <a class="el" href="rte__ethdev_8h.html#a5ac93faa0f3f69545ca121dcfd9433f5">rte_eth_rx_burst()</a> function to queue a burst of retrieved packets at a time and therefore dramatically reduce the cost of enqueue/dequeue operations per packet.</li>
<li>It allows the <a class="el" href="rte__ethdev_8h.html#a5ac93faa0f3f69545ca121dcfd9433f5">rte_eth_rx_burst()</a> function of the driver to take advantage of burst-oriented hardware features (CPU cache, prefetch instructions, and so on) to minimize the number of CPU cycles per packet.</li>
</ul>
<p>To summarize, the proposed receive API enables many burst-oriented optimizations in both synchronous and asynchronous packet processing environments with no overhead in both cases.</p>
<p>The <a class="el" href="rte__ethdev_8h.html#a5ac93faa0f3f69545ca121dcfd9433f5">rte_eth_rx_burst()</a> function does not provide any error notification to avoid the corresponding overhead. As a hint, the upper-level application might check the status of the device link once being systematically returned a 0 value for a given number of tries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the receive queue from which to retrieve input packets. The value must be in the range [0, nb_rx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#ac30d075b4b206c7122e200164ce69893">rte_eth_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">rx_pkts</td><td>The address of an array of pointers to <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> structures that must be large enough to store <em>nb_pkts</em> pointers in it. </td></tr>
    <tr><td class="paramname">nb_pkts</td><td>The maximum number of packets to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of packets actually retrieved, which is the number of pointers to <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> structures effectively supplied to the <em>rx_pkts</em> array. </dd></dl>

</div>
</div>
<a class="anchor" id="ab617761e283b6a5e1c925ab6631e384a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_eth_rx_descriptor_done </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the DD bit of the specific RX descriptor in the queue has been set</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The queue id on the specific port.  The offset of the descriptor ID from tail. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(1) if the specific DD bit is set.</li>
<li>(0) if the specific DD bit is not set.</li>
<li>(-ENODEV) if <em>port_id</em> invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a17612542dc1d0df1584819eb41a04b4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t rte_eth_rx_queue_count </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of used descriptors in a specific queue</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The queue id on the specific port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of used descriptors in the specific queue. </dd></dl>

</div>
</div>
<a class="anchor" id="a8db38c1bb895250a99b217bb24126d8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_rx_queue_setup </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>rx_queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_rx_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__eth__rxconf.html">rte_eth_rxconf</a> *&#160;</td>
          <td class="paramname"><em>rx_conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mb_pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate and set up a receive queue for an Ethernet device.</p>
<p>The function allocates a contiguous block of memory for <em>nb_rx_desc</em> receive descriptors from a memory zone associated with <em>socket_id</em> and initializes each receive descriptor with a network buffer allocated from the memory pool <em>mb_pool</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">rx_queue_id</td><td>The index of the receive queue to set up. The value must be in the range [0, nb_rx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#ac30d075b4b206c7122e200164ce69893">rte_eth_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">nb_rx_desc</td><td>The number of receive descriptors to allocate for the receive ring. </td></tr>
    <tr><td class="paramname">socket_id</td><td>The <em>socket_id</em> argument is the socket identifier in case of NUMA. The value can be <em>SOCKET_ID_ANY</em> if there is no NUMA constraint for the DMA memory allocated for the receive descriptors of the ring. </td></tr>
    <tr><td class="paramname">rx_conf</td><td>The pointer to the configuration data to be used for the receive queue. The <em>rx_conf</em> structure contains an <em>rx_thresh</em> structure with the values of the Prefetch, Host, and Write-Back threshold registers of the receive ring. </td></tr>
    <tr><td class="paramname">mb_pool</td><td>The pointer to the memory pool from which to allocate <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> network memory buffers to populate each descriptor of the receive ring. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, receive queue correctly set up.</li>
<li>-EINVAL: The size of network buffers which can be allocated from the memory pool does not fit the various buffer sizes allowed by the device controller.</li>
<li>-ENOMEM: Unable to allocate the receive ring descriptors or to allocate network memory buffers from the memory pool when initializing receive descriptors. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af2f26d83cdddce57512653a811244e22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_set_queue_rate_limit </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tx_rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the rate limitation for a queue on an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_idx</td><td>The queue id. </td></tr>
    <tr><td class="paramname">tx_rate</td><td>The tx rate allocated from the total link speed for this queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support this feature.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a84873c5b3c3968e8e18ca3043750f7cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_set_vf_rate_limit </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>vf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tx_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>q_msk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the rate limitation for a vf on an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">vf</td><td>VF id. </td></tr>
    <tr><td class="paramname">tx_rate</td><td>The tx rate allocated from the total link speed for this VF id. </td></tr>
    <tr><td class="paramname">q_msk</td><td>The queue mask which need to set the rate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>(0) if successful.</li>
<li>(-ENOTSUP) if hardware doesn't support this feature.</li>
<li>(-ENODEV) if <em>port_id</em> invalid.</li>
<li>(-EINVAL) if bad parameter. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aac7b274a66c959f827a0750eaf22a5cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_eth_stats_get </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__eth__stats.html">rte_eth_stats</a> *&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the general I/O statistics of an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">stats</td><td>A pointer to a structure of type <em><a class="el" href="structrte__eth__stats.html">rte_eth_stats</a></em> to be filled with the values of device counters for the following set of statistics:<ul>
<li><em>ipackets</em> with the total of successfully received packets.</li>
<li><em>opackets</em> with the total of successfully transmitted packets.</li>
<li><em>ibytes</em> with the total of successfully received bytes.</li>
<li><em>obytes</em> with the total of successfully transmitted bytes.</li>
<li><em>ierrors</em> with the total of erroneous received packets.</li>
<li><em>oerrors</em> with the total of failed transmitted packets. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2d4c21999ce13ae488b825e597645a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_eth_stats_reset </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the general I/O statistics of an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8053f1efd106a1d939e77f97566846b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_eth_tx_burst </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> **&#160;</td>
          <td class="paramname"><em>tx_pkts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_pkts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Send a burst of output packets on a transmit queue of an Ethernet device.</p>
<p>The <a class="el" href="rte__ethdev_8h.html#a8053f1efd106a1d939e77f97566846b0">rte_eth_tx_burst()</a> function is invoked to transmit output packets on the output queue <em>queue_id</em> of the Ethernet device designated by its <em>port_id</em>. The <em>nb_pkts</em> parameter is the number of packets to send which are supplied in the <em>tx_pkts</em> array of <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> structures. The <a class="el" href="rte__ethdev_8h.html#a8053f1efd106a1d939e77f97566846b0">rte_eth_tx_burst()</a> function loops, sending <em>nb_pkts</em> packets, up to the number of transmit descriptors available in the TX ring of the transmit queue. For each packet to send, the <a class="el" href="rte__ethdev_8h.html#a8053f1efd106a1d939e77f97566846b0">rte_eth_tx_burst()</a> function performs the following operations:</p>
<ul>
<li>Pick up the next available descriptor in the transmit ring.</li>
<li>Free the network buffer previously sent with that descriptor, if any.</li>
<li>Initialize the transmit descriptor with the information provided in the *rte_mbuf data structure.</li>
</ul>
<p>In the case of a segmented packet composed of a list of <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> buffers, the <a class="el" href="rte__ethdev_8h.html#a8053f1efd106a1d939e77f97566846b0">rte_eth_tx_burst()</a> function uses several transmit descriptors of the ring.</p>
<p>The <a class="el" href="rte__ethdev_8h.html#a8053f1efd106a1d939e77f97566846b0">rte_eth_tx_burst()</a> function returns the number of packets it actually sent. A return value equal to <em>nb_pkts</em> means that all packets have been sent, and this is likely to signify that other output packets could be immediately transmitted again. Applications that implement a "send as many packets to transmit as possible" policy can check this specific case and keep invoking the <a class="el" href="rte__ethdev_8h.html#a8053f1efd106a1d939e77f97566846b0">rte_eth_tx_burst()</a> function until a value less than <em>nb_pkts</em> is returned.</p>
<p>It is the responsibility of the <a class="el" href="rte__ethdev_8h.html#a8053f1efd106a1d939e77f97566846b0">rte_eth_tx_burst()</a> function to transparently free the memory buffers of packets previously sent. This feature is driven by the <em>tx_free_thresh</em> value supplied to the <a class="el" href="rte__ethdev_8h.html#ac30d075b4b206c7122e200164ce69893">rte_eth_dev_configure()</a> function at device configuration time. When the number of previously sent packets reached the "minimum transmit
packets to free" threshold, the <a class="el" href="rte__ethdev_8h.html#a8053f1efd106a1d939e77f97566846b0">rte_eth_tx_burst()</a> function must [attempt to] free the <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> buffers of those packets whose transmission was effectively completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">queue_id</td><td>The index of the transmit queue through which output packets must be sent. The value must be in the range [0, nb_tx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#ac30d075b4b206c7122e200164ce69893">rte_eth_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">tx_pkts</td><td>The address of an array of <em>nb_pkts</em> pointers to <em><a class="el" href="structrte__mbuf.html">rte_mbuf</a></em> structures which contain the output packets. </td></tr>
    <tr><td class="paramname">nb_pkts</td><td>The maximum number of packets to transmit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of output packets actually stored in transmit descriptors of the transmit ring. The return value can be less than the value of the <em>tx_pkts</em> parameter when the transmit ring is full or has been filled up. </dd></dl>

</div>
</div>
<a class="anchor" id="af4b9fe682d4487fb3efecc40d08d04a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_eth_tx_queue_setup </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tx_queue_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>nb_tx_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__eth__txconf.html">rte_eth_txconf</a> *&#160;</td>
          <td class="paramname"><em>tx_conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate and set up a transmit queue for an Ethernet device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port_id</td><td>The port identifier of the Ethernet device. </td></tr>
    <tr><td class="paramname">tx_queue_id</td><td>The index of the transmit queue to set up. The value must be in the range [0, nb_tx_queue - 1] previously supplied to <a class="el" href="rte__ethdev_8h.html#ac30d075b4b206c7122e200164ce69893">rte_eth_dev_configure()</a>. </td></tr>
    <tr><td class="paramname">nb_tx_desc</td><td>The number of transmit descriptors to allocate for the transmit ring. </td></tr>
    <tr><td class="paramname">socket_id</td><td>The <em>socket_id</em> argument is the socket identifier in case of NUMA. Its value can be <em>SOCKET_ID_ANY</em> if there is no NUMA constraint for the DMA memory allocated for the transmit descriptors of the ring. </td></tr>
    <tr><td class="paramname">tx_conf</td><td>The pointer to the configuration data to be used for the transmit queue. The <em>tx_conf</em> structure contains the following data:<ul>
<li>The <em>tx_thresh</em> structure with the values of the Prefetch, Host, and Write-Back threshold registers of the transmit ring. When setting Write-Back threshold to the value greater then zero, <em>tx_rs_thresh</em> value should be explicitly set to one.</li>
<li>The <em>tx_free_thresh</em> value indicates the [minimum] number of network buffers that must be pending in the transmit ring to trigger their [implicit] freeing by the driver transmit function.</li>
<li>The <em>tx_rs_thresh</em> value indicates the [minimum] number of transmit descriptors that must be pending in the transmit ring before setting the RS bit on a descriptor by the driver transmit function. The <em>tx_rs_thresh</em> value should be less or equal then <em>tx_free_thresh</em> value, and both of them should be less then <em>nb_tx_desc</em> - 3.</li>
<li><p class="startli">The <em>txq_flags</em> member contains flags to pass to the TX queue setup function to configure the behavior of the TX queue. This should be set to 0 if no special configuration is required.</p>
<p class="startli">Note that setting <em>tx_free_thresh</em> or <em>tx_rs_thresh</em> value to 0 forces the transmit function to use default values. </p>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success, the transmit queue is correctly set up.</li>
<li>-ENOMEM: Unable to allocate the transmit ring descriptors. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
