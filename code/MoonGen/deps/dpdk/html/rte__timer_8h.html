<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>DPDK: lib/librte_timer/rte_timer.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_fcaecf9e47d3074427ceb27ca105ed74.html">lib</a></li><li class="navelem"><a class="el" href="dir_e91602910079ad01c985cf11650d47ab.html">librte_timer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_timer.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionrte__timer__status.html">rte_timer_status</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__timer.html">rte_timer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a396b590f00383861a04cf3b59d604788"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__timer_8h.html#a396b590f00383861a04cf3b59d604788">RTE_TIMER_STOP</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a396b590f00383861a04cf3b59d604788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd0e7f83be69292b2fcc335002162f0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__timer_8h.html#abdd0e7f83be69292b2fcc335002162f0">RTE_TIMER_PENDING</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:abdd0e7f83be69292b2fcc335002162f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bab75fd20f0dade070198baaf338093"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__timer_8h.html#a1bab75fd20f0dade070198baaf338093">RTE_TIMER_RUNNING</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a1bab75fd20f0dade070198baaf338093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab81be0a8b461d613f432293dc01b032a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__timer_8h.html#ab81be0a8b461d613f432293dc01b032a">RTE_TIMER_CONFIG</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:ab81be0a8b461d613f432293dc01b032a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af987ae48c84d4da33ec5936d3c6214a3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__timer_8h.html#af987ae48c84d4da33ec5936d3c6214a3">RTE_TIMER_NO_OWNER</a>&#160;&#160;&#160;-1</td></tr>
<tr class="separator:af987ae48c84d4da33ec5936d3c6214a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe831655dc7ca10a2d58c18ee7e3de51"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__timer_8h.html#abe831655dc7ca10a2d58c18ee7e3de51">RTE_TIMER_INITIALIZER</a></td></tr>
<tr class="separator:abe831655dc7ca10a2d58c18ee7e3de51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a356e4838f67b60ffba867110c1ef0f7e"><td class="memItemLeft" align="right" valign="top">typedef void(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__timer_8h.html#a356e4838f67b60ffba867110c1ef0f7e">rte_timer_cb_t</a>) (struct <a class="el" href="structrte__timer.html">rte_timer</a> *, void *)</td></tr>
<tr class="separator:a356e4838f67b60ffba867110c1ef0f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a5a5cb38c85e7504eda9c02a5dcefd0a7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__timer_8h.html#a5a5cb38c85e7504eda9c02a5dcefd0a7">rte_timer_type</a> </td></tr>
<tr class="separator:a5a5cb38c85e7504eda9c02a5dcefd0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8d518f0091fc8475df83aec716c2be02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__timer_8h.html#a8d518f0091fc8475df83aec716c2be02">rte_timer_subsystem_init</a> (void)</td></tr>
<tr class="separator:a8d518f0091fc8475df83aec716c2be02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69340aa2987e22053aa8b88140fe18bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__timer_8h.html#a69340aa2987e22053aa8b88140fe18bb">rte_timer_init</a> (struct <a class="el" href="structrte__timer.html">rte_timer</a> *tim)</td></tr>
<tr class="separator:a69340aa2987e22053aa8b88140fe18bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707296972ed4a11384b661653eb94187"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__timer_8h.html#a707296972ed4a11384b661653eb94187">rte_timer_reset</a> (struct <a class="el" href="structrte__timer.html">rte_timer</a> *tim, uint64_t ticks, enum <a class="el" href="rte__timer_8h.html#a5a5cb38c85e7504eda9c02a5dcefd0a7">rte_timer_type</a> type, unsigned tim_lcore, <a class="el" href="rte__timer_8h.html#a356e4838f67b60ffba867110c1ef0f7e">rte_timer_cb_t</a> fct, void *arg)</td></tr>
<tr class="separator:a707296972ed4a11384b661653eb94187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a030b92ab3b05f0c9b1bd0c2cc0bbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__timer_8h.html#a62a030b92ab3b05f0c9b1bd0c2cc0bbf">rte_timer_reset_sync</a> (struct <a class="el" href="structrte__timer.html">rte_timer</a> *tim, uint64_t ticks, enum <a class="el" href="rte__timer_8h.html#a5a5cb38c85e7504eda9c02a5dcefd0a7">rte_timer_type</a> type, unsigned tim_lcore, <a class="el" href="rte__timer_8h.html#a356e4838f67b60ffba867110c1ef0f7e">rte_timer_cb_t</a> fct, void *arg)</td></tr>
<tr class="separator:a62a030b92ab3b05f0c9b1bd0c2cc0bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab542d925bd43062013453bea656628"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__timer_8h.html#a6ab542d925bd43062013453bea656628">rte_timer_stop</a> (struct <a class="el" href="structrte__timer.html">rte_timer</a> *tim)</td></tr>
<tr class="separator:a6ab542d925bd43062013453bea656628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f28bb6cfb080e85c96090218fe5836e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__timer_8h.html#a0f28bb6cfb080e85c96090218fe5836e">rte_timer_stop_sync</a> (struct <a class="el" href="structrte__timer.html">rte_timer</a> *tim)</td></tr>
<tr class="separator:a0f28bb6cfb080e85c96090218fe5836e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4b64d60de5510f1f84945bb30e720e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__timer_8h.html#a4f4b64d60de5510f1f84945bb30e720e">rte_timer_pending</a> (struct <a class="el" href="structrte__timer.html">rte_timer</a> *tim)</td></tr>
<tr class="separator:a4f4b64d60de5510f1f84945bb30e720e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4db2fe15d7d04a511408e39cad9d50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__timer_8h.html#a4c4db2fe15d7d04a511408e39cad9d50">rte_timer_manage</a> (void)</td></tr>
<tr class="separator:a4c4db2fe15d7d04a511408e39cad9d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc50f344f5078a6191ee1c6ab010d35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__timer_8h.html#acdc50f344f5078a6191ee1c6ab010d35">rte_timer_dump_stats</a> (FILE *f)</td></tr>
<tr class="separator:acdc50f344f5078a6191ee1c6ab010d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE Timer</p>
<p>This library provides a timer service to RTE Data Plane execution units that allows the execution of callback functions asynchronously.</p>
<ul>
<li>Timers can be periodic or single (one-shot).</li>
<li>The timers can be loaded from one core and executed on another. This has to be specified in the call to <a class="el" href="rte__timer_8h.html#a707296972ed4a11384b661653eb94187">rte_timer_reset()</a>.</li>
<li>High precision is possible. NOTE: this depends on the call frequency to <a class="el" href="rte__timer_8h.html#a4c4db2fe15d7d04a511408e39cad9d50">rte_timer_manage()</a> that check the timer expiration for the local core.</li>
<li>If not used in an application, for improved performance, it can be disabled at compilation time by not calling the <a class="el" href="rte__timer_8h.html#a4c4db2fe15d7d04a511408e39cad9d50">rte_timer_manage()</a> to improve performance.</li>
</ul>
<p>The timer library uses the rte_get_hpet_cycles() function that uses the HPET, when available, to provide a reliable time reference. [HPET routines are provided by EAL, which falls back to using the chip TSC (time- stamp counter) as fallback when HPET is not available]</p>
<p>This library provides an interface to add, delete and restart a timer. The API is based on the BSD callout(9) API with a few differences.</p>
<p>See the RTE architecture documentation for more information about the design of this library. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ab81be0a8b461d613f432293dc01b032a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_TIMER_CONFIG&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>State: timer is being configured. </p>

</div>
</div>
<a class="anchor" id="abe831655dc7ca10a2d58c18ee7e3de51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_TIMER_INITIALIZER</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                      \</div>
<div class="line">        .status = {{                         \</div>
<div class="line">            .state = <a class="code" href="rte__timer_8h.html#a396b590f00383861a04cf3b59d604788">RTE_TIMER_STOP</a>,     \</div>
<div class="line">            .owner = <a class="code" href="rte__timer_8h.html#af987ae48c84d4da33ec5936d3c6214a3">RTE_TIMER_NO_OWNER</a>, \</div>
<div class="line">        }},                                  \</div>
<div class="line">    }</div>
<div class="ttc" id="rte__timer_8h_html_af987ae48c84d4da33ec5936d3c6214a3"><div class="ttname"><a href="rte__timer_8h.html#af987ae48c84d4da33ec5936d3c6214a3">RTE_TIMER_NO_OWNER</a></div><div class="ttdeci">#define RTE_TIMER_NO_OWNER</div><div class="ttdef"><b>Definition:</b> rte_timer.h:79</div></div>
<div class="ttc" id="rte__timer_8h_html_a396b590f00383861a04cf3b59d604788"><div class="ttname"><a href="rte__timer_8h.html#a396b590f00383861a04cf3b59d604788">RTE_TIMER_STOP</a></div><div class="ttdeci">#define RTE_TIMER_STOP</div><div class="ttdef"><b>Definition:</b> rte_timer.h:74</div></div>
</div><!-- fragment --><p>A static initializer for a timer structure. </p>

</div>
</div>
<a class="anchor" id="af987ae48c84d4da33ec5936d3c6214a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_TIMER_NO_OWNER&#160;&#160;&#160;-1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Timer has no owner. </p>

</div>
</div>
<a class="anchor" id="abdd0e7f83be69292b2fcc335002162f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_TIMER_PENDING&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>State: timer is scheduled. </p>

</div>
</div>
<a class="anchor" id="a1bab75fd20f0dade070198baaf338093"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_TIMER_RUNNING&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>State: timer function is running. </p>

</div>
</div>
<a class="anchor" id="a396b590f00383861a04cf3b59d604788"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_TIMER_STOP&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>State: timer is stopped. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a356e4838f67b60ffba867110c1ef0f7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( rte_timer_cb_t) (struct <a class="el" href="structrte__timer.html">rte_timer</a> *, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Callback function type for timer expiry. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a5a5cb38c85e7504eda9c02a5dcefd0a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__timer_8h.html#a5a5cb38c85e7504eda9c02a5dcefd0a7">rte_timer_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Timer type: Periodic or single (one-shot). </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="acdc50f344f5078a6191ee1c6ab010d35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_timer_dump_stats </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump statistics about timers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A pointer to a file for output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a69340aa2987e22053aa8b88140fe18bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_timer_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__timer.html">rte_timer</a> *&#160;</td>
          <td class="paramname"><em>tim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a timer handle.</p>
<p>The <a class="el" href="rte__timer_8h.html#a69340aa2987e22053aa8b88140fe18bb">rte_timer_init()</a> function initializes the timer handle <em>tim</em> for use. No operations can be performed on a timer before it is initialized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tim</td><td>The timer to initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c4db2fe15d7d04a511408e39cad9d50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_timer_manage </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Manage the timer list and execute callback functions.</p>
<p>This function must be called periodically from all cores main_loop(). It browses the list of pending timers and runs all timers that are expired.</p>
<p>The precision of the timer depends on the call frequency of this function. However, the more often the function is called, the more CPU resources it will use. </p>

</div>
</div>
<a class="anchor" id="a4f4b64d60de5510f1f84945bb30e720e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_timer_pending </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__timer.html">rte_timer</a> *&#160;</td>
          <td class="paramname"><em>tim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if a timer is pending.</p>
<p>The <a class="el" href="rte__timer_8h.html#a4f4b64d60de5510f1f84945bb30e720e">rte_timer_pending()</a> function tests the PENDING status of the timer handle <em>tim</em>. A PENDING timer is one that has been scheduled and whose function has not yet been called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tim</td><td>The timer handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: The timer is not pending.</li>
<li>1: The timer is pending. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a707296972ed4a11384b661653eb94187"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_timer_reset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__timer.html">rte_timer</a> *&#160;</td>
          <td class="paramname"><em>tim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ticks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__timer_8h.html#a5a5cb38c85e7504eda9c02a5dcefd0a7">rte_timer_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>tim_lcore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__timer_8h.html#a356e4838f67b60ffba867110c1ef0f7e">rte_timer_cb_t</a>&#160;</td>
          <td class="paramname"><em>fct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset and start the timer associated with the timer handle.</p>
<p>The <a class="el" href="rte__timer_8h.html#a707296972ed4a11384b661653eb94187">rte_timer_reset()</a> function resets and starts the timer associated with the timer handle <em>tim</em>. When the timer expires after <em>ticks</em> HPET cycles, the function specified by <em>fct</em> will be called with the argument <em>arg</em> on core <em>tim_lcore</em>.</p>
<p>If the timer associated with the timer handle is already running (in the RUNNING state), the function will fail. The user has to check the return value of the function to see if there is a chance that the timer is in the RUNNING state.</p>
<p>If the timer is being configured on another core (the CONFIG state), it will also fail.</p>
<p>If the timer is pending or stopped, it will be rescheduled with the new parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tim</td><td>The timer handle. </td></tr>
    <tr><td class="paramname">ticks</td><td>The number of cycles (see rte_get_hpet_hz()) before the callback function is called. </td></tr>
    <tr><td class="paramname">type</td><td>The type can be either:<ul>
<li>PERIODICAL: The timer is automatically reloaded after execution (returns to the PENDING state)</li>
<li>SINGLE: The timer is one-shot, that is, the timer goes to a STOPPED state after execution. </li>
</ul>
</td></tr>
    <tr><td class="paramname">tim_lcore</td><td>The ID of the lcore where the timer callback function has to be executed. If tim_lcore is LCORE_ID_ANY, the timer library will launch it on a different core for each call (round-robin). </td></tr>
    <tr><td class="paramname">fct</td><td>The callback function of the timer. </td></tr>
    <tr><td class="paramname">arg</td><td>The user argument of the callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; the timer is scheduled.</li>
<li>(-1): Timer is in the RUNNING or CONFIG state. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a62a030b92ab3b05f0c9b1bd0c2cc0bbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_timer_reset_sync </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__timer.html">rte_timer</a> *&#160;</td>
          <td class="paramname"><em>tim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ticks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__timer_8h.html#a5a5cb38c85e7504eda9c02a5dcefd0a7">rte_timer_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>tim_lcore</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__timer_8h.html#a356e4838f67b60ffba867110c1ef0f7e">rte_timer_cb_t</a>&#160;</td>
          <td class="paramname"><em>fct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loop until <a class="el" href="rte__timer_8h.html#a707296972ed4a11384b661653eb94187">rte_timer_reset()</a> succeeds.</p>
<p>Reset and start the timer associated with the timer handle. Always succeed. See <a class="el" href="rte__timer_8h.html#a707296972ed4a11384b661653eb94187">rte_timer_reset()</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tim</td><td>The timer handle. </td></tr>
    <tr><td class="paramname">ticks</td><td>The number of cycles (see rte_get_hpet_hz()) before the callback function is called. </td></tr>
    <tr><td class="paramname">type</td><td>The type can be either:<ul>
<li>PERIODICAL: The timer is automatically reloaded after execution (returns to the PENDING state)</li>
<li>SINGLE: The timer is one-shot, that is, the timer goes to a STOPPED state after execution. </li>
</ul>
</td></tr>
    <tr><td class="paramname">tim_lcore</td><td>The ID of the lcore where the timer callback function has to be executed. If tim_lcore is LCORE_ID_ANY, the timer library will launch it on a different core for each call (round-robin). </td></tr>
    <tr><td class="paramname">fct</td><td>The callback function of the timer. </td></tr>
    <tr><td class="paramname">arg</td><td>The user argument of the callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ab542d925bd43062013453bea656628"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rte_timer_stop </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__timer.html">rte_timer</a> *&#160;</td>
          <td class="paramname"><em>tim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop a timer.</p>
<p>The <a class="el" href="rte__timer_8h.html#a6ab542d925bd43062013453bea656628">rte_timer_stop()</a> function stops the timer associated with the timer handle <em>tim</em>. It may fail if the timer is currently running or being configured.</p>
<p>If the timer is pending or stopped (for instance, already expired), the function will succeed. The timer handle tim must have been initialized using <a class="el" href="rte__timer_8h.html#a69340aa2987e22053aa8b88140fe18bb">rte_timer_init()</a>, otherwise, undefined behavior will occur.</p>
<p>This function can be called safely from a timer callback. If it succeeds, the timer is not referenced anymore by the timer library and the timer structure can be freed (even in the callback function).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tim</td><td>The timer handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; the timer is stopped.</li>
<li>(-1): The timer is in the RUNNING or CONFIG state. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0f28bb6cfb080e85c96090218fe5836e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_timer_stop_sync </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__timer.html">rte_timer</a> *&#160;</td>
          <td class="paramname"><em>tim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loop until <a class="el" href="rte__timer_8h.html#a6ab542d925bd43062013453bea656628">rte_timer_stop()</a> succeeds.</p>
<p>After a call to this function, the timer identified by <em>tim</em> is stopped. See <a class="el" href="rte__timer_8h.html#a6ab542d925bd43062013453bea656628">rte_timer_stop()</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tim</td><td>The timer handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d518f0091fc8475df83aec716c2be02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_timer_subsystem_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the timer library.</p>
<p>Initializes internal variables (list, locks and so on) for the RTE timer library. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
