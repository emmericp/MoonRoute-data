<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>DPDK: lib/librte_mempool/rte_mempool.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_fcaecf9e47d3074427ceb27ca105ed74.html">lib</a></li><li class="navelem"><a class="el" href="dir_32deba5031aa5674c1328e0739515946.html">librte_mempool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_mempool.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;inttypes.h&gt;</code><br />
<code>#include &lt;sys/queue.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__log_8h.html">rte_log.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__debug_8h.html">rte_debug.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__lcore_8h.html">rte_lcore.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__memory_8h.html">rte_memory.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__branch__prediction_8h.html">rte_branch_prediction.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__ring_8h.html">rte_ring.h</a>&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__mempool.html">rte_mempool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ace39cb6a7415a12e81e534c084eaffae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#ace39cb6a7415a12e81e534c084eaffae">RTE_MEMPOOL_HEADER_COOKIE1</a>&#160;&#160;&#160;0xbadbadbadadd2e55ULL</td></tr>
<tr class="separator:ace39cb6a7415a12e81e534c084eaffae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734531a6320af1bd65287929672b5dd7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a734531a6320af1bd65287929672b5dd7">RTE_MEMPOOL_HEADER_COOKIE2</a>&#160;&#160;&#160;0xf2eef2eedadd2e55ULL</td></tr>
<tr class="separator:a734531a6320af1bd65287929672b5dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6419c9ccd761d970b756c37e25d72dd7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a6419c9ccd761d970b756c37e25d72dd7">RTE_MEMPOOL_TRAILER_COOKIE</a>&#160;&#160;&#160;0xadd2e55badbadbadULL</td></tr>
<tr class="separator:a6419c9ccd761d970b756c37e25d72dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e5aa92b19f0f8d981b7016264456d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#af6e5aa92b19f0f8d981b7016264456d7">RTE_MEMPOOL_NAMESIZE</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:af6e5aa92b19f0f8d981b7016264456d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0648fad3d8d844ccf917cbebe9f741"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a2f0648fad3d8d844ccf917cbebe9f741">MEMPOOL_PG_NUM_DEFAULT</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a2f0648fad3d8d844ccf917cbebe9f741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2274675362f7964be2bc499e55782eb5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a2274675362f7964be2bc499e55782eb5">MEMPOOL_F_NO_SPREAD</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="separator:a2274675362f7964be2bc499e55782eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4b50b6c6c3a097d768c8337d146caa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a7f4b50b6c6c3a097d768c8337d146caa">MEMPOOL_F_NO_CACHE_ALIGN</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="separator:a7f4b50b6c6c3a097d768c8337d146caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee48ca768ddf8494f6618ca54e2e84e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#aee48ca768ddf8494f6618ca54e2e84e9">MEMPOOL_F_SP_PUT</a>&#160;&#160;&#160;0x0004</td></tr>
<tr class="separator:aee48ca768ddf8494f6618ca54e2e84e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08a019547fb3968e73aab0dafefc069"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#ab08a019547fb3968e73aab0dafefc069">MEMPOOL_F_SC_GET</a>&#160;&#160;&#160;0x0008</td></tr>
<tr class="separator:ab08a019547fb3968e73aab0dafefc069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3570153f46e8b03b81cb854f609d8fca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a3570153f46e8b03b81cb854f609d8fca">MEMPOOL_HEADER_SIZE</a>(mp,  pgn)</td></tr>
<tr class="separator:a3570153f46e8b03b81cb854f609d8fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35f443eaacec8c4f305eac54c5e01a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#af35f443eaacec8c4f305eac54c5e01a2">MEMPOOL_IS_CONTIG</a>(mp)</td></tr>
<tr class="separator:af35f443eaacec8c4f305eac54c5e01a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a88b9825126e1dbe5b8d51ad08bf76d5c"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a88b9825126e1dbe5b8d51ad08bf76d5c">rte_mempool_obj_iter_t</a>) (void *, void *, void *, uint32_t)</td></tr>
<tr class="separator:a88b9825126e1dbe5b8d51ad08bf76d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4620d8fd1c008e44f429188bac7b8c8"><td class="memItemLeft" align="right" valign="top">typedef void(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#ae4620d8fd1c008e44f429188bac7b8c8">rte_mempool_obj_ctor_t</a>) (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *, void *, void *, unsigned)</td></tr>
<tr class="separator:ae4620d8fd1c008e44f429188bac7b8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87cd14676c0857b4dd54868626d4c6ee"><td class="memItemLeft" align="right" valign="top">typedef void(&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a87cd14676c0857b4dd54868626d4c6ee">rte_mempool_ctor_t</a>) (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *, void *)</td></tr>
<tr class="separator:a87cd14676c0857b4dd54868626d4c6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a91c974c3b7721025e9c8052a940d190d"><td class="memItemLeft" align="right" valign="top">static const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a91c974c3b7721025e9c8052a940d190d">rte_mempool_from_obj</a> (void *obj)</td></tr>
<tr class="separator:a91c974c3b7721025e9c8052a940d190d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc1d01a45144e3203c36d1800cb8f17"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a7dc1d01a45144e3203c36d1800cb8f17">rte_mempool_create</a> (const char *name, unsigned n, unsigned elt_size, unsigned cache_size, unsigned private_data_size, <a class="el" href="rte__mempool_8h.html#a87cd14676c0857b4dd54868626d4c6ee">rte_mempool_ctor_t</a> *mp_init, void *mp_init_arg, <a class="el" href="rte__mempool_8h.html#ae4620d8fd1c008e44f429188bac7b8c8">rte_mempool_obj_ctor_t</a> *obj_init, void *obj_init_arg, int socket_id, unsigned flags)</td></tr>
<tr class="separator:a7dc1d01a45144e3203c36d1800cb8f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1921c0e704757b024cb79604db40f4"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a5c1921c0e704757b024cb79604db40f4">rte_mempool_xmem_create</a> (const char *name, unsigned n, unsigned elt_size, unsigned cache_size, unsigned private_data_size, <a class="el" href="rte__mempool_8h.html#a87cd14676c0857b4dd54868626d4c6ee">rte_mempool_ctor_t</a> *mp_init, void *mp_init_arg, <a class="el" href="rte__mempool_8h.html#ae4620d8fd1c008e44f429188bac7b8c8">rte_mempool_obj_ctor_t</a> *obj_init, void *obj_init_arg, int socket_id, unsigned flags, void *vaddr, const <a class="el" href="rte__memory_8h.html#aeed7e715f3dcfddef6f34dec94037646">phys_addr_t</a> paddr[], uint32_t pg_num, uint32_t pg_shift)</td></tr>
<tr class="separator:a5c1921c0e704757b024cb79604db40f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97cea3286380dbf5ee641efd8d6c442b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a97cea3286380dbf5ee641efd8d6c442b">rte_mempool_dump</a> (FILE *f, const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:a97cea3286380dbf5ee641efd8d6c442b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305999d4289856a541855ca22dce91ea"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a305999d4289856a541855ca22dce91ea">rte_mempool_mp_put_bulk</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void *const *obj_table, unsigned n)</td></tr>
<tr class="separator:a305999d4289856a541855ca22dce91ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e0ad89db728923a7f84e56633346e6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a13e0ad89db728923a7f84e56633346e6">rte_mempool_sp_put_bulk</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void *const *obj_table, unsigned n)</td></tr>
<tr class="separator:a13e0ad89db728923a7f84e56633346e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46972d2b6e77edd375231453667ce46b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a46972d2b6e77edd375231453667ce46b">rte_mempool_put_bulk</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void *const *obj_table, unsigned n)</td></tr>
<tr class="separator:a46972d2b6e77edd375231453667ce46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ad267e5cb87337aa1fa83b72ead46f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a13ad267e5cb87337aa1fa83b72ead46f">rte_mempool_mp_put</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void *obj)</td></tr>
<tr class="separator:a13ad267e5cb87337aa1fa83b72ead46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15870119eb7b2816112d44c0fd98b585"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a15870119eb7b2816112d44c0fd98b585">rte_mempool_sp_put</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void *obj)</td></tr>
<tr class="separator:a15870119eb7b2816112d44c0fd98b585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3def6fc59b18be5c983c05de0df5f918"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a3def6fc59b18be5c983c05de0df5f918">rte_mempool_put</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void *obj)</td></tr>
<tr class="separator:a3def6fc59b18be5c983c05de0df5f918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05723e7135fedf8ba6756af8be71e1ca"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a05723e7135fedf8ba6756af8be71e1ca">rte_mempool_mc_get_bulk</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void **obj_table, unsigned n)</td></tr>
<tr class="separator:a05723e7135fedf8ba6756af8be71e1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6393ce89533dae2212de148aab30dd"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a4d6393ce89533dae2212de148aab30dd">rte_mempool_sc_get_bulk</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void **obj_table, unsigned n)</td></tr>
<tr class="separator:a4d6393ce89533dae2212de148aab30dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a6b5afb4ed66c57c375e7d794e7781"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a51a6b5afb4ed66c57c375e7d794e7781">rte_mempool_get_bulk</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void **obj_table, unsigned n)</td></tr>
<tr class="separator:a51a6b5afb4ed66c57c375e7d794e7781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369fa1b1e5d9664c85e94ef58a463b82"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a369fa1b1e5d9664c85e94ef58a463b82">rte_mempool_mc_get</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void **obj_p)</td></tr>
<tr class="separator:a369fa1b1e5d9664c85e94ef58a463b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47538ab596fd4b69e151f8a8962da8a1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a47538ab596fd4b69e151f8a8962da8a1">rte_mempool_sc_get</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void **obj_p)</td></tr>
<tr class="separator:a47538ab596fd4b69e151f8a8962da8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bffea924acb47a9ec321abb21ea0c5"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#ad1bffea924acb47a9ec321abb21ea0c5">rte_mempool_get</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void **obj_p)</td></tr>
<tr class="separator:ad1bffea924acb47a9ec321abb21ea0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1c868324f15c80e1956ee87249704b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a4e1c868324f15c80e1956ee87249704b">rte_mempool_count</a> (const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:a4e1c868324f15c80e1956ee87249704b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80976616504e426555f8eda95050b998"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a80976616504e426555f8eda95050b998">rte_mempool_free_count</a> (const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:a80976616504e426555f8eda95050b998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a83e5cc7f9d57f154839b1c80992a3"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a85a83e5cc7f9d57f154839b1c80992a3">rte_mempool_full</a> (const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:a85a83e5cc7f9d57f154839b1c80992a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ad83873c9af9bc2012153cd4b4ed52"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#ad6ad83873c9af9bc2012153cd4b4ed52">rte_mempool_empty</a> (const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:ad6ad83873c9af9bc2012153cd4b4ed52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8285cccb4078582d361b505891bd0a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rte__memory_8h.html#aeed7e715f3dcfddef6f34dec94037646">phys_addr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a8c8285cccb4078582d361b505891bd0a">rte_mempool_virt2phy</a> (const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, const void *elt)</td></tr>
<tr class="separator:a8c8285cccb4078582d361b505891bd0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b29b84fb7ca24d252abab5f830daa7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a1b29b84fb7ca24d252abab5f830daa7b">rte_mempool_audit</a> (const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:a1b29b84fb7ca24d252abab5f830daa7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b794c0cd2a78c74817b250becf981fc"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a6b794c0cd2a78c74817b250becf981fc">rte_mempool_get_priv</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:a6b794c0cd2a78c74817b250becf981fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1120319a35b0cf0b23827705b2229a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#acb1120319a35b0cf0b23827705b2229a">rte_mempool_list_dump</a> (FILE *f)</td></tr>
<tr class="separator:acb1120319a35b0cf0b23827705b2229a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5887135fc6329a35780b0053e769ad"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a3a5887135fc6329a35780b0053e769ad">rte_mempool_lookup</a> (const char *name)</td></tr>
<tr class="separator:a3a5887135fc6329a35780b0053e769ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121d699436738109067ed80a1ecae38f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a121d699436738109067ed80a1ecae38f">rte_mempool_calc_obj_size</a> (uint32_t elt_size, uint32_t flags, struct rte_mempool_objsz *sz)</td></tr>
<tr class="separator:a121d699436738109067ed80a1ecae38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f017f9b78ab1bc71abd21d0bf233e8f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a1f017f9b78ab1bc71abd21d0bf233e8f">rte_mempool_xmem_size</a> (uint32_t elt_num, size_t elt_sz, uint32_t pg_shift)</td></tr>
<tr class="separator:a1f017f9b78ab1bc71abd21d0bf233e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf5dd195fbbb5e0d3b35212bfef534c"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#a7bf5dd195fbbb5e0d3b35212bfef534c">rte_mempool_xmem_usage</a> (void *vaddr, uint32_t elt_num, size_t elt_sz, const <a class="el" href="rte__memory_8h.html#aeed7e715f3dcfddef6f34dec94037646">phys_addr_t</a> paddr[], uint32_t pg_num, uint32_t pg_shift)</td></tr>
<tr class="separator:a7bf5dd195fbbb5e0d3b35212bfef534c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac813bddbff225d65d111dda5a1974b3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mempool_8h.html#ac813bddbff225d65d111dda5a1974b3f">rte_mempool_walk</a> (void(*func)(const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *, void *arg), void *arg)</td></tr>
<tr class="separator:ac813bddbff225d65d111dda5a1974b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE Mempool.</p>
<p>A memory pool is an allocator of fixed-size object. It is identified by its name, and uses a ring to store free objects. It provides some other optional services, like a per-core object cache, and an alignment helper to ensure that objects are padded to spread them equally on all RAM channels, ranks, and so on.</p>
<p>Objects owned by a mempool should never be added in another mempool. When an object is freed using <a class="el" href="rte__mempool_8h.html#a3def6fc59b18be5c983c05de0df5f918">rte_mempool_put()</a> or equivalent, the object data is not modified; the user can save some meta-data in the object data and retrieve them when allocating a new object.</p>
<p>Note: the mempool implementation is not preemptable. A lcore must not be interrupted by another task that uses the same mempool (because it uses a ring which is not preemptable). Also, mempool functions must not be used outside the DPDK environment: for example, in linuxapp environment, a thread that is not created by the EAL must not use mempools. This is due to the per-lcore cache that won't work as <a class="el" href="rte__lcore_8h.html#adfb2b334e7e73f534f25e8888a8a775f">rte_lcore_id()</a> will not return a correct value. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a7f4b50b6c6c3a097d768c8337d146caa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMPOOL_F_NO_CACHE_ALIGN&#160;&#160;&#160;0x0002</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do not align objs on cache lines. </p>

</div>
</div>
<a class="anchor" id="a2274675362f7964be2bc499e55782eb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMPOOL_F_NO_SPREAD&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do not spread in memory. </p>

</div>
</div>
<a class="anchor" id="ab08a019547fb3968e73aab0dafefc069"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMPOOL_F_SC_GET&#160;&#160;&#160;0x0008</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default get is "single-consumer". </p>

</div>
</div>
<a class="anchor" id="aee48ca768ddf8494f6618ca54e2e84e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMPOOL_F_SP_PUT&#160;&#160;&#160;0x0004</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default put is "single-producer". </p>

</div>
</div>
<a class="anchor" id="a3570153f46e8b03b81cb854f609d8fca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMPOOL_HEADER_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pgn&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(<span class="keyword">sizeof</span>(*(mp)) + <a class="code" href="rte__common_8h.html#a856650153655096752b4c2a29690a15d">\</a></div>
<div class="line"><a class="code" href="rte__common_8h.html#a856650153655096752b4c2a29690a15d">	RTE_ALIGN_CEIL</a>(((pgn) - <a class="code" href="rte__common_8h.html#ac963da91b35efa4700b73a1f4eb1d8a6">RTE_DIM</a>((mp)-&gt;elt_pa)) * \</div>
<div class="line">    <span class="keyword">sizeof</span> ((mp)-&gt;elt_pa[0]), <a class="code" href="rte__memory_8h.html#af89f60b07247176687889ade776c8e10">CACHE_LINE_SIZE</a>))</div>
<div class="ttc" id="rte__common_8h_html_a856650153655096752b4c2a29690a15d"><div class="ttname"><a href="rte__common_8h.html#a856650153655096752b4c2a29690a15d">RTE_ALIGN_CEIL</a></div><div class="ttdeci">#define RTE_ALIGN_CEIL(val, align)</div><div class="ttdef"><b>Definition:</b> rte_common.h:141</div></div>
<div class="ttc" id="rte__common_8h_html_ac963da91b35efa4700b73a1f4eb1d8a6"><div class="ttname"><a href="rte__common_8h.html#ac963da91b35efa4700b73a1f4eb1d8a6">RTE_DIM</a></div><div class="ttdeci">#define RTE_DIM(a)</div><div class="ttdef"><b>Definition:</b> rte_common.h:322</div></div>
<div class="ttc" id="rte__memory_8h_html_af89f60b07247176687889ade776c8e10"><div class="ttname"><a href="rte__memory_8h.html#af89f60b07247176687889ade776c8e10">CACHE_LINE_SIZE</a></div><div class="ttdeci">#define CACHE_LINE_SIZE</div><div class="ttdef"><b>Definition:</b> rte_memory.h:63</div></div>
</div><!-- fragment --><p>Calculates size of the mempool header. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>Pointer to the memory pool. </td></tr>
    <tr><td class="paramname">pgn</td><td>Number of page used to store mempool objects. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af35f443eaacec8c4f305eac54c5e01a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMPOOL_IS_CONTIG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mp</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((mp)-&gt;pg_num == <a class="code" href="rte__mempool_8h.html#a2f0648fad3d8d844ccf917cbebe9f741">MEMPOOL_PG_NUM_DEFAULT</a> &amp;&amp; \</div>
<div class="line">    (mp)-&gt;phys_addr == (mp)-&gt;elt_pa[0])</div>
<div class="ttc" id="rte__mempool_8h_html_a2f0648fad3d8d844ccf917cbebe9f741"><div class="ttname"><a href="rte__mempool_8h.html#a2f0648fad3d8d844ccf917cbebe9f741">MEMPOOL_PG_NUM_DEFAULT</a></div><div class="ttdeci">#define MEMPOOL_PG_NUM_DEFAULT</div><div class="ttdef"><b>Definition:</b> rte_mempool.h:140</div></div>
</div><!-- fragment --><p>Returns TRUE if whole mempool is allocated in one contiguous block of memory. </p>

</div>
</div>
<a class="anchor" id="a2f0648fad3d8d844ccf917cbebe9f741"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEMPOOL_PG_NUM_DEFAULT&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mempool over one chunk of physically continuous memory </p>

</div>
</div>
<a class="anchor" id="ace39cb6a7415a12e81e534c084eaffae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MEMPOOL_HEADER_COOKIE1&#160;&#160;&#160;0xbadbadbadadd2e55ULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Header cookie. </p>

</div>
</div>
<a class="anchor" id="a734531a6320af1bd65287929672b5dd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MEMPOOL_HEADER_COOKIE2&#160;&#160;&#160;0xf2eef2eedadd2e55ULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Header cookie. </p>

</div>
</div>
<a class="anchor" id="af6e5aa92b19f0f8d981b7016264456d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MEMPOOL_NAMESIZE&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum length of a memory pool. </p>

</div>
</div>
<a class="anchor" id="a6419c9ccd761d970b756c37e25d72dd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MEMPOOL_TRAILER_COOKIE&#160;&#160;&#160;0xadd2e55badbadbadULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trailer cookie. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a87cd14676c0857b4dd54868626d4c6ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( rte_mempool_ctor_t) (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A mempool constructor callback function.</p>
<p>Arguments are the mempool and the opaque pointer given by the user in <a class="el" href="rte__mempool_8h.html#a7dc1d01a45144e3203c36d1800cb8f17">rte_mempool_create()</a>. </p>

</div>
</div>
<a class="anchor" id="ae4620d8fd1c008e44f429188bac7b8c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void( rte_mempool_obj_ctor_t) (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *, void *, void *, unsigned)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An object constructor callback function for mempool.</p>
<p>Arguments are the mempool, the opaque pointer given by the user in <a class="el" href="rte__mempool_8h.html#a7dc1d01a45144e3203c36d1800cb8f17">rte_mempool_create()</a>, the pointer to the element and the index of the element in the pool. </p>

</div>
</div>
<a class="anchor" id="a88b9825126e1dbe5b8d51ad08bf76d5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* rte_mempool_obj_iter_t) (void *, void *, void *, uint32_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An mempool's object iterator callback function. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a1b29b84fb7ca24d252abab5f830daa7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_mempool_audit </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check the consistency of mempool objects.</p>
<p>Verify the coherency of fields in the mempool structure. Also check that the cookies of mempool objects (even the ones that are not present in pool) have a correct value. If not, a panic will occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a121d699436738109067ed80a1ecae38f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rte_mempool_calc_obj_size </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>elt_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct rte_mempool_objsz *&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a desired size of the mempool element and mempool flags, caluclates header, trailer, body and total sizes of the mempool object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt_size</td><td>The size of each element. </td></tr>
    <tr><td class="paramname">flags</td><td>The flags used for the mempool creation. Consult <a class="el" href="rte__mempool_8h.html#a7dc1d01a45144e3203c36d1800cb8f17">rte_mempool_create()</a> for more information about possible values. The size of each element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total size of the mempool object. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e1c868324f15c80e1956ee87249704b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned rte_mempool_count </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of entries in the mempool.</p>
<p>When cache is enabled, this function has to browse the length of all lcores, so it should not be used in a data path, but only for debug purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of entries in the mempool. </dd></dl>

</div>
</div>
<a class="anchor" id="a7dc1d01a45144e3203c36d1800cb8f17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__mempool.html">rte_mempool</a>* rte_mempool_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>elt_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>cache_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>private_data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__mempool_8h.html#a87cd14676c0857b4dd54868626d4c6ee">rte_mempool_ctor_t</a> *&#160;</td>
          <td class="paramname"><em>mp_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mp_init_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__mempool_8h.html#ae4620d8fd1c008e44f429188bac7b8c8">rte_mempool_obj_ctor_t</a> *&#160;</td>
          <td class="paramname"><em>obj_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj_init_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new mempool named <em>name</em> in memory.</p>
<p>This function uses <code>memzone_reserve()</code> to allocate memory. The pool contains n elements of elt_size. Its size is set to n. All elements of the mempool are allocated together with the mempool header, in one physically continuous chunk of memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the mempool. </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements in the mempool. The optimum size (in terms of memory usage) for a mempool is when n is a power of two minus one: n = (2^q - 1). </td></tr>
    <tr><td class="paramname">elt_size</td><td>The size of each element. </td></tr>
    <tr><td class="paramname">cache_size</td><td>If cache_size is non-zero, the <a class="el" href="structrte__mempool.html">rte_mempool</a> library will try to limit the accesses to the common lockless pool, by maintaining a per-lcore object cache. This argument must be lower or equal to CONFIG_RTE_MEMPOOL_CACHE_MAX_SIZE. It is advised to choose cache_size to have "n modulo cache_size == 0": if this is not the case, some elements will always stay in the pool and will never be used. The access to the per-lcore table is of course faster than the multi-producer/consumer pool. The cache can be disabled if the cache_size argument is set to 0; it can be useful to avoid losing objects in cache. Note that even if not used, the memory space for cache is always reserved in a mempool structure, except if CONFIG_RTE_MEMPOOL_CACHE_MAX_SIZE is set to 0. </td></tr>
    <tr><td class="paramname">private_data_size</td><td>The size of the private data appended after the mempool structure. This is useful for storing some private data after the mempool structure, as is done for rte_mbuf_pool for example. </td></tr>
    <tr><td class="paramname">mp_init</td><td>A function pointer that is called for initialization of the pool, before object initialization. The user can initialize the private data in this function if needed. This parameter can be NULL if not needed. </td></tr>
    <tr><td class="paramname">mp_init_arg</td><td>An opaque pointer to data that can be used in the mempool constructor function. </td></tr>
    <tr><td class="paramname">obj_init</td><td>A function pointer that is called for each object at initialization of the pool. The user can set some meta data in objects if needed. This parameter can be NULL if not needed. The obj_init() function takes the mempool pointer, the init_arg, the object pointer and the object number as parameters. </td></tr>
    <tr><td class="paramname">obj_init_arg</td><td>An opaque pointer to data that can be used as an argument for each call to the object constructor function. </td></tr>
    <tr><td class="paramname">socket_id</td><td>The <em>socket_id</em> argument is the socket identifier in the case of NUMA. The value can be <em>SOCKET_ID_ANY</em> if there is no NUMA constraint for the reserved zone. </td></tr>
    <tr><td class="paramname">flags</td><td>The <em>flags</em> arguments is an OR of following flags:<ul>
<li>MEMPOOL_F_NO_SPREAD: By default, objects addresses are spread between channels in RAM: the pool allocator will add padding between objects depending on the hardware configuration. See Memory alignment constraints for details. If this flag is set, the allocator will just align them to a cache line.</li>
<li>MEMPOOL_F_NO_CACHE_ALIGN: By default, the returned objects are cache-aligned. This flag removes this constraint, and no padding will be present between objects. This flag implies MEMPOOL_F_NO_SPREAD.</li>
<li>MEMPOOL_F_SP_PUT: If this flag is set, the default behavior when using <a class="el" href="rte__mempool_8h.html#a3def6fc59b18be5c983c05de0df5f918">rte_mempool_put()</a> or <a class="el" href="rte__mempool_8h.html#a46972d2b6e77edd375231453667ce46b">rte_mempool_put_bulk()</a> is "single-producer". Otherwise, it is "multi-producers".</li>
<li>MEMPOOL_F_SC_GET: If this flag is set, the default behavior when using <a class="el" href="rte__mempool_8h.html#ad1bffea924acb47a9ec321abb21ea0c5">rte_mempool_get()</a> or <a class="el" href="rte__mempool_8h.html#a51a6b5afb4ed66c57c375e7d794e7781">rte_mempool_get_bulk()</a> is "single-consumer". Otherwise, it is "multi-consumers". </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the new allocated mempool, on success. NULL on error with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>E_RTE_NO_CONFIG - function could not get pointer to <a class="el" href="structrte__config.html">rte_config</a> structure</li>
<li>E_RTE_SECONDARY - function was called from a secondary process instance</li>
<li>E_RTE_NO_TAILQ - no tailq list could be got for the ring or mempool list</li>
<li>EINVAL - cache size provided is too large</li>
<li>ENOSPC - the maximum number of memzones has already been allocated</li>
<li>EEXIST - a memzone with the same name already exists</li>
<li>ENOMEM - no appropriate memory area found in which to create memzone </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a97cea3286380dbf5ee641efd8d6c442b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_mempool_dump </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump the status of the mempool to the console.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A pointer to a file for output </td></tr>
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad6ad83873c9af9bc2012153cd4b4ed52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_mempool_empty </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test if the mempool is empty.</p>
<p>When cache is enabled, this function has to browse the length of all lcores, so it should not be used in a data path, but only for debug purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>1: The mempool is empty.</li>
<li>0: The mempool is not empty. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a80976616504e426555f8eda95050b998"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned rte_mempool_free_count </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of free entries in the mempool ring. i.e. how many entries can be freed back to the mempool.</p>
<p>NOTE: This corresponds to the number of elements <em>allocated</em> from the memory pool, not the number of elements in the pool itself. To count the number elements currently available in the pool, use "rte_mempool_count"</p>
<p>When cache is enabled, this function has to browse the length of all lcores, so it should not be used in a data path, but only for debug purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of free entries in the mempool. </dd></dl>

</div>
</div>
<a class="anchor" id="a91c974c3b7721025e9c8052a940d190d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const struct <a class="el" href="structrte__mempool.html">rte_mempool</a>* rte_mempool_from_obj </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the mempool owning this object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>An object that is owned by a pool. If this is not the case, the behavior is undefined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the mempool structure. </dd></dl>

</div>
</div>
<a class="anchor" id="a85a83e5cc7f9d57f154839b1c80992a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_mempool_full </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test if the mempool is full.</p>
<p>When cache is enabled, this function has to browse the length of all lcores, so it should not be used in a data path, but only for debug purposes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>1: The mempool is full.</li>
<li>0: The mempool is not full. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad1bffea924acb47a9ec321abb21ea0c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_mempool_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get one object from the mempool.</p>
<p>This function calls the multi-consumers or the single-consumer version, depending on the default behavior that was specified at mempool creation (see flags).</p>
<p>If cache is enabled, objects will be retrieved first from cache, subsequently from the common pool. Note that it can return -ENOENT when the local cache and common pool are empty, even if cache from other lcores are full.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj_p</td><td>A pointer to a void * pointer (object) that will be filled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects taken.</li>
<li>-ENOENT: Not enough entries in the mempool; no object is retrieved. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a51a6b5afb4ed66c57c375e7d794e7781"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_mempool_get_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get several objects from the mempool.</p>
<p>This function calls the multi-consumers or the single-consumer version, depending on the default behaviour that was specified at mempool creation time (see flags).</p>
<p>If cache is enabled, objects will be retrieved first from cache, subsequently from the common pool. Note that it can return -ENOENT when the local cache and common pool are empty, even if cache from other lcores are full.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects) that will be filled. </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to get from the mempool to obj_table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects taken</li>
<li>-ENOENT: Not enough entries in the mempool; no object is retrieved. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a6b794c0cd2a78c74817b250becf981fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* rte_mempool_get_priv </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the private data in an mempool structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the private data. </dd></dl>

</div>
</div>
<a class="anchor" id="acb1120319a35b0cf0b23827705b2229a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_mempool_list_dump </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump the status of all mempools on the console</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A pointer to a file for output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a5887135fc6329a35780b0053e769ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__mempool.html">rte_mempool</a>* rte_mempool_lookup </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search a mempool from its name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the mempool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the mempool matching the name, or NULL if not found. NULL on error with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>ENOENT - required entry not available to return. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a369fa1b1e5d9664c85e94ef58a463b82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_mempool_mc_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get one object from the mempool (multi-consumers safe).</p>
<p>If cache is enabled, objects will be retrieved first from cache, subsequently from the common pool. Note that it can return -ENOENT when the local cache and common pool are empty, even if cache from other lcores are full.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj_p</td><td>A pointer to a void * pointer (object) that will be filled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects taken.</li>
<li>-ENOENT: Not enough entries in the mempool; no object is retrieved. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a05723e7135fedf8ba6756af8be71e1ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_mempool_mc_get_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get several objects from the mempool (multi-consumers safe).</p>
<p>If cache is enabled, objects will be retrieved first from cache, subsequently from the common pool. Note that it can return -ENOENT when the local cache and common pool are empty, even if cache from other lcores are full.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects) that will be filled. </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to get from mempool to obj_table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects taken.</li>
<li>-ENOENT: Not enough entries in the mempool; no object is retrieved. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a13ad267e5cb87337aa1fa83b72ead46f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_mempool_mp_put </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Put one object in the mempool (multi-producers safe).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj</td><td>A pointer to the object to be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a305999d4289856a541855ca22dce91ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_mempool_mp_put_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const *&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Put several objects back in the mempool (multi-producers safe).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects). </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to add in the mempool from the obj_table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3def6fc59b18be5c983c05de0df5f918"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_mempool_put </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Put one object back in the mempool.</p>
<p>This function calls the multi-producer or the single-producer version depending on the default behavior that was specified at mempool creation time (see flags).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj</td><td>A pointer to the object to be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46972d2b6e77edd375231453667ce46b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_mempool_put_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const *&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Put several objects back in the mempool.</p>
<p>This function calls the multi-producer or the single-producer version depending on the default behavior that was specified at mempool creation time (see flags).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects). </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to add in the mempool from obj_table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a47538ab596fd4b69e151f8a8962da8a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_mempool_sc_get </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get one object from the mempool (NOT multi-consumers safe).</p>
<p>If cache is enabled, objects will be retrieved first from cache, subsequently from the common pool. Note that it can return -ENOENT when the local cache and common pool are empty, even if cache from other lcores are full.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj_p</td><td>A pointer to a void * pointer (object) that will be filled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects taken.</li>
<li>-ENOENT: Not enough entries in the mempool; no object is retrieved. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a4d6393ce89533dae2212de148aab30dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_mempool_sc_get_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get several objects from the mempool (NOT multi-consumers safe).</p>
<p>If cache is enabled, objects will be retrieved first from cache, subsequently from the common pool. Note that it can return -ENOENT when the local cache and common pool are empty, even if cache from other lcores are full.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects) that will be filled. </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to get from the mempool to obj_table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success; objects taken.</li>
<li>-ENOENT: Not enough entries in the mempool; no object is retrieved. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a15870119eb7b2816112d44c0fd98b585"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_mempool_sp_put </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Put one object back in the mempool (NOT multi-producers safe).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj</td><td>A pointer to the object to be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13e0ad89db728923a7f84e56633346e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_mempool_sp_put_bulk </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const *&#160;</td>
          <td class="paramname"><em>obj_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Put several objects back in the mempool (NOT multi-producers safe).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">obj_table</td><td>A pointer to a table of void * pointers (objects). </td></tr>
    <tr><td class="paramname">n</td><td>The number of objects to add in the mempool from obj_table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c8285cccb4078582d361b505891bd0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rte__memory_8h.html#aeed7e715f3dcfddef6f34dec94037646">phys_addr_t</a> rte_mempool_virt2phy </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>elt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the physical address of elt, which is an element of the pool mp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>A pointer to the mempool structure. </td></tr>
    <tr><td class="paramname">elt</td><td>A pointer (virtual address) to the element of the pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The physical address of the elt element. </dd></dl>

</div>
</div>
<a class="anchor" id="ac813bddbff225d65d111dda5a1974b3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_mempool_walk </td>
          <td>(</td>
          <td class="paramtype">void(*)(const struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *, void *arg)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Walk list of all memory pools</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Iterator function </td></tr>
    <tr><td class="paramname">arg</td><td>Argument passed to iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5c1921c0e704757b024cb79604db40f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrte__mempool.html">rte_mempool</a>* rte_mempool_xmem_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>elt_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>cache_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>private_data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__mempool_8h.html#a87cd14676c0857b4dd54868626d4c6ee">rte_mempool_ctor_t</a> *&#160;</td>
          <td class="paramname"><em>mp_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mp_init_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rte__mempool_8h.html#ae4620d8fd1c008e44f429188bac7b8c8">rte_mempool_obj_ctor_t</a> *&#160;</td>
          <td class="paramname"><em>obj_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>obj_init_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rte__memory_8h.html#aeed7e715f3dcfddef6f34dec94037646">phys_addr_t</a>&#160;</td>
          <td class="paramname"><em>paddr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pg_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pg_shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new mempool named <em>name</em> in memory.</p>
<p>This function uses <code>memzone_reserve()</code> to allocate memory. The pool contains n elements of elt_size. Its size is set to n. Depending on the input parameters, mempool elements can be either allocated together with the mempool header, or an externally provided memory buffer could be used to store mempool objects. In later case, that external memory buffer can consist of set of disjoint phyiscal pages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the mempool. </td></tr>
    <tr><td class="paramname">n</td><td>The number of elements in the mempool. The optimum size (in terms of memory usage) for a mempool is when n is a power of two minus one: n = (2^q - 1). </td></tr>
    <tr><td class="paramname">elt_size</td><td>The size of each element. </td></tr>
    <tr><td class="paramname">cache_size</td><td>If cache_size is non-zero, the <a class="el" href="structrte__mempool.html">rte_mempool</a> library will try to limit the accesses to the common lockless pool, by maintaining a per-lcore object cache. This argument must be lower or equal to CONFIG_RTE_MEMPOOL_CACHE_MAX_SIZE. It is advised to choose cache_size to have "n modulo cache_size == 0": if this is not the case, some elements will always stay in the pool and will never be used. The access to the per-lcore table is of course faster than the multi-producer/consumer pool. The cache can be disabled if the cache_size argument is set to 0; it can be useful to avoid losing objects in cache. Note that even if not used, the memory space for cache is always reserved in a mempool structure, except if CONFIG_RTE_MEMPOOL_CACHE_MAX_SIZE is set to 0. </td></tr>
    <tr><td class="paramname">private_data_size</td><td>The size of the private data appended after the mempool structure. This is useful for storing some private data after the mempool structure, as is done for rte_mbuf_pool for example. </td></tr>
    <tr><td class="paramname">mp_init</td><td>A function pointer that is called for initialization of the pool, before object initialization. The user can initialize the private data in this function if needed. This parameter can be NULL if not needed. </td></tr>
    <tr><td class="paramname">mp_init_arg</td><td>An opaque pointer to data that can be used in the mempool constructor function. </td></tr>
    <tr><td class="paramname">obj_init</td><td>A function pointer that is called for each object at initialization of the pool. The user can set some meta data in objects if needed. This parameter can be NULL if not needed. The obj_init() function takes the mempool pointer, the init_arg, the object pointer and the object number as parameters. </td></tr>
    <tr><td class="paramname">obj_init_arg</td><td>An opaque pointer to data that can be used as an argument for each call to the object constructor function. </td></tr>
    <tr><td class="paramname">socket_id</td><td>The <em>socket_id</em> argument is the socket identifier in the case of NUMA. The value can be <em>SOCKET_ID_ANY</em> if there is no NUMA constraint for the reserved zone. </td></tr>
    <tr><td class="paramname">flags</td><td>The <em>flags</em> arguments is an OR of following flags:<ul>
<li>MEMPOOL_F_NO_SPREAD: By default, objects addresses are spread between channels in RAM: the pool allocator will add padding between objects depending on the hardware configuration. See Memory alignment constraints for details. If this flag is set, the allocator will just align them to a cache line.</li>
<li>MEMPOOL_F_NO_CACHE_ALIGN: By default, the returned objects are cache-aligned. This flag removes this constraint, and no padding will be present between objects. This flag implies MEMPOOL_F_NO_SPREAD.</li>
<li>MEMPOOL_F_SP_PUT: If this flag is set, the default behavior when using <a class="el" href="rte__mempool_8h.html#a3def6fc59b18be5c983c05de0df5f918">rte_mempool_put()</a> or <a class="el" href="rte__mempool_8h.html#a46972d2b6e77edd375231453667ce46b">rte_mempool_put_bulk()</a> is "single-producer". Otherwise, it is "multi-producers".</li>
<li>MEMPOOL_F_SC_GET: If this flag is set, the default behavior when using <a class="el" href="rte__mempool_8h.html#ad1bffea924acb47a9ec321abb21ea0c5">rte_mempool_get()</a> or <a class="el" href="rte__mempool_8h.html#a51a6b5afb4ed66c57c375e7d794e7781">rte_mempool_get_bulk()</a> is "single-consumer". Otherwise, it is "multi-consumers". </li>
</ul>
</td></tr>
    <tr><td class="paramname">vaddr</td><td>Virtual address of the externally allocated memory buffer. Will be used to store mempool objects. </td></tr>
    <tr><td class="paramname">paddr</td><td>Array of phyiscall addresses of the pages that comprises given memory buffer. </td></tr>
    <tr><td class="paramname">pg_num</td><td>Number of elements in the paddr array. </td></tr>
    <tr><td class="paramname">pg_shift</td><td>LOG2 of the physical pages size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the new allocated mempool, on success. NULL on error with rte_errno set appropriately. Possible rte_errno values include:<ul>
<li>E_RTE_NO_CONFIG - function could not get pointer to <a class="el" href="structrte__config.html">rte_config</a> structure</li>
<li>E_RTE_SECONDARY - function was called from a secondary process instance</li>
<li>E_RTE_NO_TAILQ - no tailq list could be got for the ring or mempool list</li>
<li>EINVAL - cache size provided is too large</li>
<li>ENOSPC - the maximum number of memzones has already been allocated</li>
<li>EEXIST - a memzone with the same name already exists</li>
<li>ENOMEM - no appropriate memory area found in which to create memzone </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1f017f9b78ab1bc71abd21d0bf233e8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t rte_mempool_xmem_size </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>elt_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elt_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pg_shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate maximum amount of memory required to store given number of objects. Assumes that the memory buffer will be aligned at page boundary. Note, that if object size is bigger then page size, then it assumes that we have a subsets of physically continuous pages big enough to store at least one object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elt_num</td><td>Number of elements. </td></tr>
    <tr><td class="paramname">elt_sz</td><td>The size of each element. </td></tr>
    <tr><td class="paramname">pg_shift</td><td>LOG2 of the physical pages size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Required memory size aligned at page boundary. </dd></dl>

</div>
</div>
<a class="anchor" id="a7bf5dd195fbbb5e0d3b35212bfef534c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t rte_mempool_xmem_usage </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>elt_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>elt_sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rte__memory_8h.html#aeed7e715f3dcfddef6f34dec94037646">phys_addr_t</a>&#160;</td>
          <td class="paramname"><em>paddr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pg_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pg_shift</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate how much memory would be actually required with the given memory footprint to store required number of objects. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vaddr</td><td>Virtual address of the externally allocated memory buffer. Will be used to store mempool objects. </td></tr>
    <tr><td class="paramname">elt_num</td><td>Number of elements. </td></tr>
    <tr><td class="paramname">elt_sz</td><td>The size of each element. </td></tr>
    <tr><td class="paramname">paddr</td><td>Array of phyiscall addresses of the pages that comprises given memory buffer. </td></tr>
    <tr><td class="paramname">pg_num</td><td>Number of elements in the paddr array. </td></tr>
    <tr><td class="paramname">pg_shift</td><td>LOG2 of the physical pages size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes needed to store given number of objects, aligned to the given page size. If provided memory buffer is not big enough: (-1) * actual number of elemnts that can be stored in that buffer. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
