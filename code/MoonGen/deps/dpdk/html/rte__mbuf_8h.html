<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>DPDK: lib/librte_mbuf/rte_mbuf.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DPDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_fcaecf9e47d3074427ceb27ca105ed74.html">lib</a></li><li class="navelem"><a class="el" href="dir_fd01efee497a2ed9e216d7c9bdc822ba.html">librte_mbuf</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rte_mbuf.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__mempool_8h.html">rte_mempool.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__atomic_8h.html">rte_atomic.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__prefetch_8h.html">rte_prefetch.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rte__branch__prediction_8h.html">rte_branch_prediction.h</a>&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__ctrlmbuf.html">rte_ctrlmbuf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionrte__vlan__macip.html">rte_vlan_macip</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__pktmbuf.html">rte_pktmbuf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__mbuf.html">rte_mbuf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrte__pktmbuf__pool__private.html">rte_pktmbuf_pool_private</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a0c6d1e9b9fc2c31f5476133e4370be3c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a0c6d1e9b9fc2c31f5476133e4370be3c">PKT_RX_VLAN_PKT</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="separator:a0c6d1e9b9fc2c31f5476133e4370be3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ded7bd60d9874f2c6011d0c269d4492"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a5ded7bd60d9874f2c6011d0c269d4492">PKT_RX_RSS_HASH</a>&#160;&#160;&#160;0x0002</td></tr>
<tr class="separator:a5ded7bd60d9874f2c6011d0c269d4492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4521f83d79ebbfe8a6a1b76205c21699"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a4521f83d79ebbfe8a6a1b76205c21699">PKT_RX_FDIR</a>&#160;&#160;&#160;0x0004</td></tr>
<tr class="separator:a4521f83d79ebbfe8a6a1b76205c21699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185cd397ccf014163c7d0d1a76d65eb9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a185cd397ccf014163c7d0d1a76d65eb9">PKT_RX_L4_CKSUM_BAD</a>&#160;&#160;&#160;0x0008</td></tr>
<tr class="separator:a185cd397ccf014163c7d0d1a76d65eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63578554776ee75a77d98241031ab7a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#ad63578554776ee75a77d98241031ab7a">PKT_RX_IP_CKSUM_BAD</a>&#160;&#160;&#160;0x0010</td></tr>
<tr class="separator:ad63578554776ee75a77d98241031ab7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026eafe8df454a59c4dba976eb93d0b3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a026eafe8df454a59c4dba976eb93d0b3">PKT_RX_EIP_CKSUM_BAD</a>&#160;&#160;&#160;0x0000</td></tr>
<tr class="separator:a026eafe8df454a59c4dba976eb93d0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa6cf42277d24fcabb456438a0ff9b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#aefa6cf42277d24fcabb456438a0ff9b0">PKT_RX_OVERSIZE</a>&#160;&#160;&#160;0x0000</td></tr>
<tr class="separator:aefa6cf42277d24fcabb456438a0ff9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36729827842abdc60cdad0f71583c63d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a36729827842abdc60cdad0f71583c63d">PKT_RX_HBUF_OVERFLOW</a>&#160;&#160;&#160;0x0000</td></tr>
<tr class="separator:a36729827842abdc60cdad0f71583c63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c16b3af321c6ff34a2970b6662699a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a97c16b3af321c6ff34a2970b6662699a">PKT_RX_RECIP_ERR</a>&#160;&#160;&#160;0x0000</td></tr>
<tr class="separator:a97c16b3af321c6ff34a2970b6662699a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa513865bab4deb086e4c9ce2fc6afa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#aeaa513865bab4deb086e4c9ce2fc6afa">PKT_RX_MAC_ERR</a>&#160;&#160;&#160;0x0000</td></tr>
<tr class="separator:aeaa513865bab4deb086e4c9ce2fc6afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31861612cb27c2a27827b5745dacb8c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#af31861612cb27c2a27827b5745dacb8c">PKT_RX_IPV4_HDR</a>&#160;&#160;&#160;0x0020</td></tr>
<tr class="separator:af31861612cb27c2a27827b5745dacb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38993c5da2be5c9fe74b182b075032fe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a38993c5da2be5c9fe74b182b075032fe">PKT_RX_IPV4_HDR_EXT</a>&#160;&#160;&#160;0x0040</td></tr>
<tr class="separator:a38993c5da2be5c9fe74b182b075032fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d40fdb34222fa47b9627803f1da88a0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a3d40fdb34222fa47b9627803f1da88a0">PKT_RX_IPV6_HDR</a>&#160;&#160;&#160;0x0080</td></tr>
<tr class="separator:a3d40fdb34222fa47b9627803f1da88a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967eba228c4a5e21f599f801cca767de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a967eba228c4a5e21f599f801cca767de">PKT_RX_IPV6_HDR_EXT</a>&#160;&#160;&#160;0x0100</td></tr>
<tr class="separator:a967eba228c4a5e21f599f801cca767de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7ca1953f60e88311695f3036b46dc1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a4c7ca1953f60e88311695f3036b46dc1">PKT_RX_IEEE1588_PTP</a>&#160;&#160;&#160;0x0200</td></tr>
<tr class="separator:a4c7ca1953f60e88311695f3036b46dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac53e94ad2b242eb7afe5c07f9b2ff2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#acac53e94ad2b242eb7afe5c07f9b2ff2">PKT_RX_IEEE1588_TMST</a>&#160;&#160;&#160;0x0400</td></tr>
<tr class="separator:acac53e94ad2b242eb7afe5c07f9b2ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0d1c6738680ac92bcf0f9a7ec16215"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#aab0d1c6738680ac92bcf0f9a7ec16215">PKT_TX_VLAN_PKT</a>&#160;&#160;&#160;0x0800</td></tr>
<tr class="separator:aab0d1c6738680ac92bcf0f9a7ec16215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51280725dafdf282a80b2d964418798c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a51280725dafdf282a80b2d964418798c">PKT_TX_IP_CKSUM</a>&#160;&#160;&#160;0x1000</td></tr>
<tr class="separator:a51280725dafdf282a80b2d964418798c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eebc4f47a8981d2cdad917b032b81b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a3eebc4f47a8981d2cdad917b032b81b9">PKT_TX_IPV4_CSUM</a>&#160;&#160;&#160;0x1000</td></tr>
<tr class="separator:a3eebc4f47a8981d2cdad917b032b81b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372bd340bd66cc3b906e8dff3a797ec9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a372bd340bd66cc3b906e8dff3a797ec9">PKT_TX_NO_CRC_CSUM</a>&#160;&#160;&#160;0x0001</td></tr>
<tr class="separator:a372bd340bd66cc3b906e8dff3a797ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2d4eca2fab4ef35c8f8a7f3bbe9fe2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a9d2d4eca2fab4ef35c8f8a7f3bbe9fe2">PKT_TX_IPV4</a>&#160;&#160;&#160;<a class="el" href="rte__mbuf_8h.html#af31861612cb27c2a27827b5745dacb8c">PKT_RX_IPV4_HDR</a></td></tr>
<tr class="separator:a9d2d4eca2fab4ef35c8f8a7f3bbe9fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8478d650a7d2c49b1e1a173e52d52d35"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a8478d650a7d2c49b1e1a173e52d52d35">PKT_TX_IPV6</a>&#160;&#160;&#160;<a class="el" href="rte__mbuf_8h.html#a3d40fdb34222fa47b9627803f1da88a0">PKT_RX_IPV6_HDR</a></td></tr>
<tr class="separator:a8478d650a7d2c49b1e1a173e52d52d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84461fc0150a47737cb765e5db96d868"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a84461fc0150a47737cb765e5db96d868">PKT_TX_L4_MASK</a>&#160;&#160;&#160;0x6000</td></tr>
<tr class="separator:a84461fc0150a47737cb765e5db96d868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555401418f43fe357a838856b1e49726"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a555401418f43fe357a838856b1e49726">PKT_TX_L4_NO_CKSUM</a>&#160;&#160;&#160;0x0000</td></tr>
<tr class="separator:a555401418f43fe357a838856b1e49726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4f9c739ef914bcd6c5fae63a4e2b9c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a1f4f9c739ef914bcd6c5fae63a4e2b9c">PKT_TX_TCP_CKSUM</a>&#160;&#160;&#160;0x2000</td></tr>
<tr class="separator:a1f4f9c739ef914bcd6c5fae63a4e2b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d1aa5cec10f00975ae4cd71c4c961e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#af3d1aa5cec10f00975ae4cd71c4c961e">PKT_TX_SCTP_CKSUM</a>&#160;&#160;&#160;0x4000</td></tr>
<tr class="separator:af3d1aa5cec10f00975ae4cd71c4c961e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b82ba8fa86ddfdbf9237f67a37c366"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a25b82ba8fa86ddfdbf9237f67a37c366">PKT_TX_UDP_CKSUM</a>&#160;&#160;&#160;0x6000</td></tr>
<tr class="separator:a25b82ba8fa86ddfdbf9237f67a37c366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc825dad2d8379b581b597e8ea6c42bc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#abc825dad2d8379b581b597e8ea6c42bc">PKT_TX_IEEE1588_TMST</a>&#160;&#160;&#160;0x8000</td></tr>
<tr class="separator:abc825dad2d8379b581b597e8ea6c42bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5714537b48936d64c0c7360de4801e7f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a5714537b48936d64c0c7360de4801e7f">PKT_TX_OFFLOAD_MASK</a>&#160;&#160;&#160;(<a class="el" href="rte__mbuf_8h.html#aab0d1c6738680ac92bcf0f9a7ec16215">PKT_TX_VLAN_PKT</a> | <a class="el" href="rte__mbuf_8h.html#a51280725dafdf282a80b2d964418798c">PKT_TX_IP_CKSUM</a> | <a class="el" href="rte__mbuf_8h.html#a84461fc0150a47737cb765e5db96d868">PKT_TX_L4_MASK</a>)</td></tr>
<tr class="separator:a5714537b48936d64c0c7360de4801e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca9398d26670ec47e302fd526e73356"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a5ca9398d26670ec47e302fd526e73356">TX_VLAN_CMP_MASK</a>&#160;&#160;&#160;0xFFFF0000</td></tr>
<tr class="separator:a5ca9398d26670ec47e302fd526e73356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530008ce4092f29e8d51da5e76546401"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a530008ce4092f29e8d51da5e76546401">TX_MAC_LEN_CMP_MASK</a>&#160;&#160;&#160;0x0000FE00</td></tr>
<tr class="separator:a530008ce4092f29e8d51da5e76546401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1c489d86d8d74cf9b4d4c0a811f417"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#add1c489d86d8d74cf9b4d4c0a811f417">TX_IP_LEN_CMP_MASK</a>&#160;&#160;&#160;0x000001FF</td></tr>
<tr class="separator:add1c489d86d8d74cf9b4d4c0a811f417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a886875abd1e760662791bfd4b030f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a3a886875abd1e760662791bfd4b030f1">RTE_MBUF_FROM_BADDR</a>(ba)&#160;&#160;&#160;(((struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *)(ba)) - 1)</td></tr>
<tr class="separator:a3a886875abd1e760662791bfd4b030f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56a047fab76317517a34b9bae091ad4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#ab56a047fab76317517a34b9bae091ad4">RTE_MBUF_TO_BADDR</a>(mb)&#160;&#160;&#160;(((struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *)(mb)) + 1)</td></tr>
<tr class="separator:ab56a047fab76317517a34b9bae091ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb691ea9090822fd6bd382a9f654598b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#abb691ea9090822fd6bd382a9f654598b">RTE_MBUF_INDIRECT</a>(mb)&#160;&#160;&#160;(<a class="el" href="rte__mbuf_8h.html#a3a886875abd1e760662791bfd4b030f1">RTE_MBUF_FROM_BADDR</a>((mb)-&gt;buf_addr) != (mb))</td></tr>
<tr class="separator:abb691ea9090822fd6bd382a9f654598b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63d569db3cfb4a27bc4af31d7b8d5e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#ac63d569db3cfb4a27bc4af31d7b8d5e4">RTE_MBUF_DIRECT</a>(mb)&#160;&#160;&#160;(<a class="el" href="rte__mbuf_8h.html#a3a886875abd1e760662791bfd4b030f1">RTE_MBUF_FROM_BADDR</a>((mb)-&gt;buf_addr) == (mb))</td></tr>
<tr class="separator:ac63d569db3cfb4a27bc4af31d7b8d5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4156d215249bc6856807632dda761192"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a4156d215249bc6856807632dda761192">__rte_mbuf_sanity_check</a>(m,  t,  is_h)&#160;&#160;&#160;do { } while(0)</td></tr>
<tr class="separator:a4156d215249bc6856807632dda761192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387287b946b9fde269b5d34e08c28e67"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a387287b946b9fde269b5d34e08c28e67">__rte_mbuf_sanity_check_raw</a>(m,  t,  is_h)&#160;&#160;&#160;do { } while(0)</td></tr>
<tr class="separator:a387287b946b9fde269b5d34e08c28e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78543ac3e988c070b96fee445b66e646"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a78543ac3e988c070b96fee445b66e646">RTE_MBUF_ASSERT</a>(exp)&#160;&#160;&#160;do { } while(0)</td></tr>
<tr class="separator:a78543ac3e988c070b96fee445b66e646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c79f6cb6bdeae531469d0a648d7771"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a01c79f6cb6bdeae531469d0a648d7771">RTE_MBUF_PREFETCH_TO_FREE</a>(m)</td></tr>
<tr class="separator:a01c79f6cb6bdeae531469d0a648d7771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49120430b211b2b6aab5dacfaaaf3aa1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a49120430b211b2b6aab5dacfaaaf3aa1">rte_ctrlmbuf_data</a>(m)&#160;&#160;&#160;((m)-&gt;ctrl.data)</td></tr>
<tr class="separator:a49120430b211b2b6aab5dacfaaaf3aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d5990c3ca14784ed3e0135844282a3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#ab3d5990c3ca14784ed3e0135844282a3">rte_ctrlmbuf_len</a>(m)&#160;&#160;&#160;((m)-&gt;ctrl.data_len)</td></tr>
<tr class="separator:ab3d5990c3ca14784ed3e0135844282a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8b10263496c7b580e9d0c7f2a1f073"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a2a8b10263496c7b580e9d0c7f2a1f073">rte_pktmbuf_mtod</a>(m,  t)&#160;&#160;&#160;((t)((m)-&gt;pkt.data))</td></tr>
<tr class="separator:a2a8b10263496c7b580e9d0c7f2a1f073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7ea614c79d5b9ed790a56c1c79189d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a7a7ea614c79d5b9ed790a56c1c79189d">rte_pktmbuf_pkt_len</a>(m)&#160;&#160;&#160;((m)-&gt;pkt.pkt_len)</td></tr>
<tr class="separator:a7a7ea614c79d5b9ed790a56c1c79189d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1e1b30162161ed11d3ba2faf7bbf13"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a2a1e1b30162161ed11d3ba2faf7bbf13">rte_pktmbuf_data_len</a>(m)&#160;&#160;&#160;((m)-&gt;pkt.data_len)</td></tr>
<tr class="separator:a2a1e1b30162161ed11d3ba2faf7bbf13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae899f6317cff890582d86170b44d6680"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#ae899f6317cff890582d86170b44d6680">rte_mbuf_type</a> { <a class="el" href="rte__mbuf_8h.html#ae899f6317cff890582d86170b44d6680a5c79adab7a87be7703465f4ba4c70c3f">RTE_MBUF_CTRL</a>, 
<a class="el" href="rte__mbuf_8h.html#ae899f6317cff890582d86170b44d6680a21c7a9d99631f89d88fa217e5bc5a2e9">RTE_MBUF_PKT</a>
 }</td></tr>
<tr class="separator:ae899f6317cff890582d86170b44d6680"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abb7eb5fa1599b7f6237040b95d8893de"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#abb7eb5fa1599b7f6237040b95d8893de">rte_mbuf_refcnt_update</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, int16_t value)</td></tr>
<tr class="separator:abb7eb5fa1599b7f6237040b95d8893de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cad099c1aedd46af38588ad97dabd65"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a9cad099c1aedd46af38588ad97dabd65">rte_mbuf_refcnt_read</a> (const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:a9cad099c1aedd46af38588ad97dabd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86233fc739e93e6d0136034ea7066e69"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a86233fc739e93e6d0136034ea7066e69">rte_mbuf_refcnt_set</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, uint16_t new_value)</td></tr>
<tr class="separator:a86233fc739e93e6d0136034ea7066e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34ecb67be4e095c2ea5b36206e57643"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#aa34ecb67be4e095c2ea5b36206e57643">rte_mbuf_sanity_check</a> (const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, enum <a class="el" href="rte__mbuf_8h.html#ae899f6317cff890582d86170b44d6680">rte_mbuf_type</a> t, int is_header)</td></tr>
<tr class="separator:aa34ecb67be4e095c2ea5b36206e57643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaf3671821022dc9e7d84e6dded876ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#adaf3671821022dc9e7d84e6dded876ed">rte_ctrlmbuf_init</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void *opaque_arg, void *m, unsigned i)</td></tr>
<tr class="separator:adaf3671821022dc9e7d84e6dded876ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c6c691387cc0a783fb431c84153ba2"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#aa7c6c691387cc0a783fb431c84153ba2">rte_ctrlmbuf_alloc</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:aa7c6c691387cc0a783fb431c84153ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a518f56925c23048ef724d945a62abd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a1a518f56925c23048ef724d945a62abd">rte_ctrlmbuf_free</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:a1a518f56925c23048ef724d945a62abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0d0b427cb071856f2ff0805d608e35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a7c0d0b427cb071856f2ff0805d608e35">rte_pktmbuf_init</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void *opaque_arg, void *m, unsigned i)</td></tr>
<tr class="separator:a7c0d0b427cb071856f2ff0805d608e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af714a7341cb37bc2530ac07c84c829b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#af714a7341cb37bc2530ac07c84c829b6">rte_pktmbuf_pool_init</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp, void *opaque_arg)</td></tr>
<tr class="separator:af714a7341cb37bc2530ac07c84c829b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc84d82d50361f568dd1d3a0e95d4aa4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#afc84d82d50361f568dd1d3a0e95d4aa4">rte_pktmbuf_reset</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:afc84d82d50361f568dd1d3a0e95d4aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d1c289d8cffc831dfb77c64f52447b"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#ad4d1c289d8cffc831dfb77c64f52447b">rte_pktmbuf_alloc</a> (struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:ad4d1c289d8cffc831dfb77c64f52447b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6dde16d0e43efd2d029d5ef6234ad0d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#aa6dde16d0e43efd2d029d5ef6234ad0d">rte_pktmbuf_attach</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *mi, struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *md)</td></tr>
<tr class="separator:aa6dde16d0e43efd2d029d5ef6234ad0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4a685c7386d442b658db0a6edacb43"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a6c4a685c7386d442b658db0a6edacb43">rte_pktmbuf_detach</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:a6c4a685c7386d442b658db0a6edacb43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d0817dfeb1385ae5056d67ea4eb245"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a69d0817dfeb1385ae5056d67ea4eb245">rte_pktmbuf_free_seg</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:a69d0817dfeb1385ae5056d67ea4eb245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1215458932900b7cd5192326fa4a6902"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a1215458932900b7cd5192326fa4a6902">rte_pktmbuf_free</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:a1215458932900b7cd5192326fa4a6902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d26cc982f6363cd7492dd70cc5c287c"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a1d26cc982f6363cd7492dd70cc5c287c">rte_pktmbuf_clone</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *md, struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *mp)</td></tr>
<tr class="separator:a1d26cc982f6363cd7492dd70cc5c287c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac5629940550649a2ef40029f5ad21a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a7ac5629940550649a2ef40029f5ad21a">rte_pktmbuf_refcnt_update</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, int16_t v)</td></tr>
<tr class="separator:a7ac5629940550649a2ef40029f5ad21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a67c1b6a6b7c07e488d5fed7b03502d"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a2a67c1b6a6b7c07e488d5fed7b03502d">rte_pktmbuf_headroom</a> (const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:a2a67c1b6a6b7c07e488d5fed7b03502d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257bc8af3e8fde7eb6603bdf4ae0528e"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a257bc8af3e8fde7eb6603bdf4ae0528e">rte_pktmbuf_tailroom</a> (const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:a257bc8af3e8fde7eb6603bdf4ae0528e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2d001cd113362dd123d663210afcbb"><td class="memItemLeft" align="right" valign="top">static struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a0c2d001cd113362dd123d663210afcbb">rte_pktmbuf_lastseg</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:a0c2d001cd113362dd123d663210afcbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf5bef4ceb0b76dfafff0895f285ab0"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#aadf5bef4ceb0b76dfafff0895f285ab0">rte_pktmbuf_prepend</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, uint16_t len)</td></tr>
<tr class="separator:aadf5bef4ceb0b76dfafff0895f285ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b0cd686ad3bcbb83416ca8395a080b"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#ad5b0cd686ad3bcbb83416ca8395a080b">rte_pktmbuf_append</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, uint16_t len)</td></tr>
<tr class="separator:ad5b0cd686ad3bcbb83416ca8395a080b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbd752194759ce7b419c4998f2e8651"><td class="memItemLeft" align="right" valign="top">static char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a1bbd752194759ce7b419c4998f2e8651">rte_pktmbuf_adj</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, uint16_t len)</td></tr>
<tr class="separator:a1bbd752194759ce7b419c4998f2e8651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1bed439015acec170d1342e8dabb3b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#abe1bed439015acec170d1342e8dabb3b">rte_pktmbuf_trim</a> (struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, uint16_t len)</td></tr>
<tr class="separator:abe1bed439015acec170d1342e8dabb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511a116ae4822037d4f1fb561aa4ffcf"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a511a116ae4822037d4f1fb561aa4ffcf">rte_pktmbuf_is_contiguous</a> (const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m)</td></tr>
<tr class="separator:a511a116ae4822037d4f1fb561aa4ffcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92788c9769a5561814c77ae2e6f65e7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rte__mbuf_8h.html#a92788c9769a5561814c77ae2e6f65e7e">rte_pktmbuf_dump</a> (FILE *f, const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *m, unsigned dump_len)</td></tr>
<tr class="separator:a92788c9769a5561814c77ae2e6f65e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>RTE Mbuf</p>
<p>The mbuf library provides the ability to create and destroy buffers that may be used by the RTE application to store message buffers. The message buffers are stored in a mempool, using the RTE mempool library.</p>
<p>This library provide an API to allocate/free mbufs, manipulate control message buffer (ctrlmbuf), which are generic message buffers, and packet buffers (pktmbuf), which are used to carry network packets.</p>
<p>To understand the concepts of packet buffers or mbufs, you should read "TCP/IP Illustrated, Volume 2: The Implementation,
Addison-Wesley, 1995, ISBN 0-201-63354-X from Richard Stevens" <a href="http://www.kohala.com/start/tcpipiv2.html">http://www.kohala.com/start/tcpipiv2.html</a></p>
<p>The main modification of this implementation is the use of mbuf for transports other than packets. mbufs can have other types. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a4156d215249bc6856807632dda761192"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __rte_mbuf_sanity_check</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">t, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">is_h&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;do { } while(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>check mbuf type in debug mode </p>

</div>
</div>
<a class="anchor" id="a387287b946b9fde269b5d34e08c28e67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define __rte_mbuf_sanity_check_raw</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">t, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">is_h&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;do { } while(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>check mbuf type in debug mode if mbuf pointer is not null </p>

</div>
</div>
<a class="anchor" id="a026eafe8df454a59c4dba976eb93d0b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_RX_EIP_CKSUM_BAD&#160;&#160;&#160;0x0000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>External IP header checksum error. </p>

</div>
</div>
<a class="anchor" id="a4521f83d79ebbfe8a6a1b76205c21699"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_RX_FDIR&#160;&#160;&#160;0x0004</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX packet with FDIR infos. </p>

</div>
</div>
<a class="anchor" id="a36729827842abdc60cdad0f71583c63d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_RX_HBUF_OVERFLOW&#160;&#160;&#160;0x0000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Header buffer overflow. </p>

</div>
</div>
<a class="anchor" id="a4c7ca1953f60e88311695f3036b46dc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_RX_IEEE1588_PTP&#160;&#160;&#160;0x0200</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX IEEE1588 L2 Ethernet PT Packet. </p>

</div>
</div>
<a class="anchor" id="acac53e94ad2b242eb7afe5c07f9b2ff2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_RX_IEEE1588_TMST&#160;&#160;&#160;0x0400</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX IEEE1588 L2/L4 timestamped packet. </p>

</div>
</div>
<a class="anchor" id="ad63578554776ee75a77d98241031ab7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_RX_IP_CKSUM_BAD&#160;&#160;&#160;0x0010</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>IP cksum of RX pkt. is not OK. </p>

</div>
</div>
<a class="anchor" id="af31861612cb27c2a27827b5745dacb8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_RX_IPV4_HDR&#160;&#160;&#160;0x0020</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX packet with IPv4 header. </p>

</div>
</div>
<a class="anchor" id="a38993c5da2be5c9fe74b182b075032fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_RX_IPV4_HDR_EXT&#160;&#160;&#160;0x0040</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX packet with extended IPv4 header. </p>

</div>
</div>
<a class="anchor" id="a3d40fdb34222fa47b9627803f1da88a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_RX_IPV6_HDR&#160;&#160;&#160;0x0080</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX packet with IPv6 header. </p>

</div>
</div>
<a class="anchor" id="a967eba228c4a5e21f599f801cca767de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_RX_IPV6_HDR_EXT&#160;&#160;&#160;0x0100</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX packet with extended IPv6 header. </p>

</div>
</div>
<a class="anchor" id="a185cd397ccf014163c7d0d1a76d65eb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_RX_L4_CKSUM_BAD&#160;&#160;&#160;0x0008</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>L4 cksum of RX pkt. is not OK. </p>

</div>
</div>
<a class="anchor" id="aeaa513865bab4deb086e4c9ce2fc6afa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_RX_MAC_ERR&#160;&#160;&#160;0x0000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>MAC error. </p>

</div>
</div>
<a class="anchor" id="aefa6cf42277d24fcabb456438a0ff9b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_RX_OVERSIZE&#160;&#160;&#160;0x0000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Num of desc of an RX pkt oversize. </p>

</div>
</div>
<a class="anchor" id="a97c16b3af321c6ff34a2970b6662699a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_RX_RECIP_ERR&#160;&#160;&#160;0x0000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hardware processing error. </p>

</div>
</div>
<a class="anchor" id="a5ded7bd60d9874f2c6011d0c269d4492"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_RX_RSS_HASH&#160;&#160;&#160;0x0002</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX packet with RSS hash result. </p>

</div>
</div>
<a class="anchor" id="a0c6d1e9b9fc2c31f5476133e4370be3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_RX_VLAN_PKT&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RX packet is a 802.1q VLAN packet. </p>

</div>
</div>
<a class="anchor" id="abc825dad2d8379b581b597e8ea6c42bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_TX_IEEE1588_TMST&#160;&#160;&#160;0x8000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TX IEEE1588 packet to timestamp. </p>

</div>
</div>
<a class="anchor" id="a51280725dafdf282a80b2d964418798c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_TX_IP_CKSUM&#160;&#160;&#160;0x1000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>IP cksum of TX pkt. computed by NIC. </p>

</div>
</div>
<a class="anchor" id="a9d2d4eca2fab4ef35c8f8a7f3bbe9fe2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_TX_IPV4&#160;&#160;&#160;<a class="el" href="rte__mbuf_8h.html#af31861612cb27c2a27827b5745dacb8c">PKT_RX_IPV4_HDR</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>IPv4 with no IP checksum offload. </p>

</div>
</div>
<a class="anchor" id="a3eebc4f47a8981d2cdad917b032b81b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_TX_IPV4_CSUM&#160;&#160;&#160;0x1000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias of PKT_TX_IP_CKSUM. </p>

</div>
</div>
<a class="anchor" id="a8478d650a7d2c49b1e1a173e52d52d35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_TX_IPV6&#160;&#160;&#160;<a class="el" href="rte__mbuf_8h.html#a3d40fdb34222fa47b9627803f1da88a0">PKT_RX_IPV6_HDR</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>IPv6 packet </p>

</div>
</div>
<a class="anchor" id="a84461fc0150a47737cb765e5db96d868"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_TX_L4_MASK&#160;&#160;&#160;0x6000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mask bits for L4 checksum offload request. </p>

</div>
</div>
<a class="anchor" id="a555401418f43fe357a838856b1e49726"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_TX_L4_NO_CKSUM&#160;&#160;&#160;0x0000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable L4 cksum of TX pkt. </p>

</div>
</div>
<a class="anchor" id="a372bd340bd66cc3b906e8dff3a797ec9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_TX_NO_CRC_CSUM&#160;&#160;&#160;0x0001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable CRC calculation. Note: overlaps with RX_VLAN_PKT. </p>

</div>
</div>
<a class="anchor" id="a5714537b48936d64c0c7360de4801e7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_TX_OFFLOAD_MASK&#160;&#160;&#160;(<a class="el" href="rte__mbuf_8h.html#aab0d1c6738680ac92bcf0f9a7ec16215">PKT_TX_VLAN_PKT</a> | <a class="el" href="rte__mbuf_8h.html#a51280725dafdf282a80b2d964418798c">PKT_TX_IP_CKSUM</a> | <a class="el" href="rte__mbuf_8h.html#a84461fc0150a47737cb765e5db96d868">PKT_TX_L4_MASK</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bit Mask to indicate what bits required for building TX context </p>

</div>
</div>
<a class="anchor" id="af3d1aa5cec10f00975ae4cd71c4c961e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_TX_SCTP_CKSUM&#160;&#160;&#160;0x4000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SCTP cksum of TX pkt. computed by NIC. </p>

</div>
</div>
<a class="anchor" id="a1f4f9c739ef914bcd6c5fae63a4e2b9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_TX_TCP_CKSUM&#160;&#160;&#160;0x2000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TCP cksum of TX pkt. computed by NIC. </p>

</div>
</div>
<a class="anchor" id="a25b82ba8fa86ddfdbf9237f67a37c366"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_TX_UDP_CKSUM&#160;&#160;&#160;0x6000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UDP cksum of TX pkt. computed by NIC. </p>

</div>
</div>
<a class="anchor" id="aab0d1c6738680ac92bcf0f9a7ec16215"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PKT_TX_VLAN_PKT&#160;&#160;&#160;0x0800</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TX packet is a 802.1q VLAN packet. </p>

</div>
</div>
<a class="anchor" id="a49120430b211b2b6aab5dacfaaaf3aa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rte_ctrlmbuf_data</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m</td><td>)</td>
          <td>&#160;&#160;&#160;((m)-&gt;ctrl.data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A macro that returns the pointer to the carried data.</p>
<p>The value that can be read or assigned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The control mbuf. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3d5990c3ca14784ed3e0135844282a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rte_ctrlmbuf_len</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m</td><td>)</td>
          <td>&#160;&#160;&#160;((m)-&gt;ctrl.data_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A macro that returns the length of the carried data.</p>
<p>The value that can be read or assigned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The control mbuf. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78543ac3e988c070b96fee445b66e646"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MBUF_ASSERT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">exp</td><td>)</td>
          <td>&#160;&#160;&#160;do { } while(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>MBUF asserts in debug mode </p>

</div>
</div>
<a class="anchor" id="ac63d569db3cfb4a27bc4af31d7b8d5e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MBUF_DIRECT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mb</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="rte__mbuf_8h.html#a3a886875abd1e760662791bfd4b030f1">RTE_MBUF_FROM_BADDR</a>((mb)-&gt;buf_addr) == (mb))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if given mbuf is direct, or FALSE otherwise. </p>

</div>
</div>
<a class="anchor" id="a3a886875abd1e760662791bfd4b030f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MBUF_FROM_BADDR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ba</td><td>)</td>
          <td>&#160;&#160;&#160;(((struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *)(ba)) - 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the buf_addr returns the pointer to corresponding mbuf. </p>

</div>
</div>
<a class="anchor" id="abb691ea9090822fd6bd382a9f654598b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MBUF_INDIRECT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mb</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="rte__mbuf_8h.html#a3a886875abd1e760662791bfd4b030f1">RTE_MBUF_FROM_BADDR</a>((mb)-&gt;buf_addr) != (mb))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns TRUE if given mbuf is indirect, or FALSE otherwise. </p>

</div>
</div>
<a class="anchor" id="a01c79f6cb6bdeae531469d0a648d7771"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MBUF_PREFETCH_TO_FREE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {       \</div>
<div class="line">    if ((m) != NULL)                        <a class="code" href="rte__prefetch_8h.html#a37f0dd7d81e95c2d3139ddf50090b6e3">\</a></div>
<div class="line"><a class="code" href="rte__prefetch_8h.html#a37f0dd7d81e95c2d3139ddf50090b6e3">		rte_prefetch0</a>(m);               \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
<div class="ttc" id="rte__prefetch_8h_html_a37f0dd7d81e95c2d3139ddf50090b6e3"><div class="ttname"><a href="rte__prefetch_8h.html#a37f0dd7d81e95c2d3139ddf50090b6e3">rte_prefetch0</a></div><div class="ttdeci">static void rte_prefetch0(volatile void *p)</div><div class="ttdef"><b>Definition:</b> rte_prefetch.h:58</div></div>
</div><!-- fragment --><p>Mbuf prefetch </p>

</div>
</div>
<a class="anchor" id="ab56a047fab76317517a34b9bae091ad4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTE_MBUF_TO_BADDR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mb</td><td>)</td>
          <td>&#160;&#160;&#160;(((struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *)(mb)) + 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the pointer to mbuf returns an address where it's buf_addr should point to. </p>

</div>
</div>
<a class="anchor" id="a2a1e1b30162161ed11d3ba2faf7bbf13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rte_pktmbuf_data_len</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m</td><td>)</td>
          <td>&#160;&#160;&#160;((m)-&gt;pkt.data_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A macro that returns the length of the segment.</p>
<p>The value can be read or assigned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a8b10263496c7b580e9d0c7f2a1f073"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rte_pktmbuf_mtod</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">t&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((t)((m)-&gt;pkt.data))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A macro that points to the start of the data in the mbuf.</p>
<p>The returned pointer is cast to type t. Before using this function, the user must ensure that m_headlen(m) is large enough to read its data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf. </td></tr>
    <tr><td class="paramname">t</td><td>The type to cast the result into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a7ea614c79d5b9ed790a56c1c79189d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rte_pktmbuf_pkt_len</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m</td><td>)</td>
          <td>&#160;&#160;&#160;((m)-&gt;pkt.pkt_len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A macro that returns the length of the packet.</p>
<p>The value can be read or assigned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add1c489d86d8d74cf9b4d4c0a811f417"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TX_IP_LEN_CMP_MASK&#160;&#160;&#160;0x000001FF</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>IP length - 9-bits. MAC+IP length. </p>

</div>
</div>
<a class="anchor" id="a530008ce4092f29e8d51da5e76546401"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TX_MAC_LEN_CMP_MASK&#160;&#160;&#160;0x0000FE00</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>MAC length - 7-bits. </p>

</div>
</div>
<a class="anchor" id="a5ca9398d26670ec47e302fd526e73356"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TX_VLAN_CMP_MASK&#160;&#160;&#160;0xFFFF0000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>VLAN length - 16-bits. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ae899f6317cff890582d86170b44d6680"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rte__mbuf_8h.html#ae899f6317cff890582d86170b44d6680">rte_mbuf_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enum indicates the mbuf type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ae899f6317cff890582d86170b44d6680a5c79adab7a87be7703465f4ba4c70c3f"></a>RTE_MBUF_CTRL&#160;</td><td class="fielddoc">
<p>Control mbuf. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae899f6317cff890582d86170b44d6680a21c7a9d99631f89d88fa217e5bc5a2e9"></a>RTE_MBUF_PKT&#160;</td><td class="fielddoc">
<p>Packet mbuf. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aa7c6c691387cc0a783fb431c84153ba2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a>* rte_ctrlmbuf_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate a new mbuf (type is ctrl) from mempool <em>mp</em>.</p>
<p>This new mbuf is initialized with data pointing to the beginning of buffer, and with a length of zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>The mempool from which the mbuf is allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The pointer to the new mbuf on success.</li>
<li>NULL if allocation failed. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1a518f56925c23048ef724d945a62abd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_ctrlmbuf_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Free a control mbuf back into its original mempool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The control mbuf to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adaf3671821022dc9e7d84e6dded876ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_ctrlmbuf_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The control mbuf constructor.</p>
<p>This function initializes some fields in an mbuf structure that are not modified by the user once created (mbuf type, origin pool, buffer start address, and so on). This function is given as a callback function to <a class="el" href="rte__mempool_8h.html#a7dc1d01a45144e3203c36d1800cb8f17">rte_mempool_create()</a> at pool creation time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>The mempool from which the mbuf is allocated. </td></tr>
    <tr><td class="paramname">opaque_arg</td><td>A pointer that can be used by the user to retrieve useful information for mbuf initialization. This pointer comes from the <code>init_arg</code> parameter of <a class="el" href="rte__mempool_8h.html#a7dc1d01a45144e3203c36d1800cb8f17">rte_mempool_create()</a>. </td></tr>
    <tr><td class="paramname">m</td><td>The mbuf to initialize. </td></tr>
    <tr><td class="paramname">i</td><td>The index of the mbuf in the pool table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9cad099c1aedd46af38588ad97dabd65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_mbuf_refcnt_read </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads the value of an mbuf's refcnt. </p>

</div>
</div>
<a class="anchor" id="a86233fc739e93e6d0136034ea7066e69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_mbuf_refcnt_set </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets an mbuf's refcnt to the defined value. </p>

</div>
</div>
<a class="anchor" id="abb7eb5fa1599b7f6237040b95d8893de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_mbuf_refcnt_update </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds given value to an mbuf's refcnt and returns its new value. </p>

</div>
</div>
<a class="anchor" id="aa34ecb67be4e095c2ea5b36206e57643"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_mbuf_sanity_check </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="rte__mbuf_8h.html#ae899f6317cff890582d86170b44d6680">rte_mbuf_type</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>is_header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sanity checks on an mbuf.</p>
<p>Check the consistency of the given mbuf. The function will cause a panic if corruption is detected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The mbuf to be checked. </td></tr>
    <tr><td class="paramname">t</td><td>The expected type of the mbuf. </td></tr>
    <tr><td class="paramname">is_header</td><td>True if the mbuf is a packet header, false if it is a sub-segment of a packet (in this case, some fields like nb_segs are not checked) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1bbd752194759ce7b419c4998f2e8651"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char* rte_pktmbuf_adj </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove len bytes at the beginning of an mbuf.</p>
<p>Returns a pointer to the start address of the new data area. If the length is greater than the length of the first segment, then the function will fail and return NULL, without modifying the mbuf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf. </td></tr>
    <tr><td class="paramname">len</td><td>The amount of data to remove (in bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the new start of the data. </dd></dl>

</div>
</div>
<a class="anchor" id="ad4d1c289d8cffc831dfb77c64f52447b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a>* rte_pktmbuf_alloc </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate a new mbuf (type is pkt) from a mempool.</p>
<p>This new mbuf contains one segment, which has a length of 0. The pointer to data is initialized to have some bytes of headroom in the buffer (if buffer size allows).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>The mempool from which the mbuf is allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The pointer to the new mbuf on success.</li>
<li>NULL if allocation failed. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad5b0cd686ad3bcbb83416ca8395a080b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char* rte_pktmbuf_append </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Append len bytes to an mbuf.</p>
<p>Append len bytes to an mbuf and return a pointer to the start address of the added data. If there is not enough tailroom in the last segment, the function will return NULL, without modifying the mbuf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf. </td></tr>
    <tr><td class="paramname">len</td><td>The amount of data to append (in bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the start of the newly appended data, or NULL if there is not enough tailroom space in the last segment </dd></dl>

</div>
</div>
<a class="anchor" id="aa6dde16d0e43efd2d029d5ef6234ad0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_pktmbuf_attach </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>mi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>md</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attach packet mbuf to another packet mbuf. After attachment we refer the mbuf we attached as 'indirect', while mbuf we attached to as 'direct'. Right now, not supported:</p><ul>
<li>attachment to indirect mbuf (e.g. - md has to be direct).</li>
<li>attachment for already indirect mbuf (e.g. - mi has to be direct).</li>
<li>mbuf we trying to attach (mi) is used by someone else e.g. it's reference counter is greater then 1.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mi</td><td>The indirect packet mbuf. </td></tr>
    <tr><td class="paramname">md</td><td>The direct packet mbuf. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d26cc982f6363cd7492dd70cc5c287c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a>* rte_pktmbuf_clone </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>md</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a "clone" of the given packet mbuf.</p>
<p>Walks through all segments of the given packet mbuf, and for each of them:</p><ul>
<li>Creates a new packet mbuf from the given pool.</li>
<li>Attaches newly created mbuf to the segment. Then updates pkt_len and nb_segs of the "clone" packet mbuf to match values from the original packet mbuf.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">md</td><td>The packet mbuf to be cloned. </td></tr>
    <tr><td class="paramname">mp</td><td>The mempool from which the "clone" mbufs are allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The pointer to the new "clone" mbuf on success.</li>
<li>NULL if allocation fails. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a6c4a685c7386d442b658db0a6edacb43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_pktmbuf_detach </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Detach an indirect packet mbuf -</p><ul>
<li>restore original mbuf address and length values.</li>
<li>reset pktmbuf data and data_len to their default values. All other fields of the given packet mbuf will be left intact.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The indirect attached packet mbuf. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92788c9769a5561814c77ae2e6f65e7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_pktmbuf_dump </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dump_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump an mbuf structure to the console.</p>
<p>Dump all fields for the given packet mbuf and all its associated segments (in the case of a chained buffer).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A pointer to a file for output </td></tr>
    <tr><td class="paramname">m</td><td>The packet mbuf. </td></tr>
    <tr><td class="paramname">dump_len</td><td>If dump_len != 0, also dump the "dump_len" first data bytes of the packet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1215458932900b7cd5192326fa4a6902"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_pktmbuf_free </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Free a packet mbuf back into its original mempool.</p>
<p>Free an mbuf, and all its segments in case of chained buffers. Each segment is added back into its original mempool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a69d0817dfeb1385ae5056d67ea4eb245"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_pktmbuf_free_seg </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Free a segment of a packet mbuf into its original mempool.</p>
<p>Free an mbuf, without parsing other segments in case of chained buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf segment to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a67c1b6a6b7c07e488d5fed7b03502d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_pktmbuf_headroom </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the headroom in a packet mbuf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the headroom. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c0d0b427cb071856f2ff0805d608e35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_pktmbuf_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The packet mbuf constructor.</p>
<p>This function initializes some fields in the mbuf structure that are not modified by the user once created (mbuf type, origin pool, buffer start address, and so on). This function is given as a callback function to <a class="el" href="rte__mempool_8h.html#a7dc1d01a45144e3203c36d1800cb8f17">rte_mempool_create()</a> at pool creation time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>The mempool from which mbufs originate. </td></tr>
    <tr><td class="paramname">opaque_arg</td><td>A pointer that can be used by the user to retrieve useful information for mbuf initialization. This pointer comes from the <code>init_arg</code> parameter of <a class="el" href="rte__mempool_8h.html#a7dc1d01a45144e3203c36d1800cb8f17">rte_mempool_create()</a>. </td></tr>
    <tr><td class="paramname">m</td><td>The mbuf to initialize. </td></tr>
    <tr><td class="paramname">i</td><td>The index of the mbuf in the pool table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a511a116ae4822037d4f1fb561aa4ffcf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_pktmbuf_is_contiguous </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test if mbuf data is contiguous.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>1, if all data is contiguous (one segment).</li>
<li>0, if there is several segments. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0c2d001cd113362dd123d663210afcbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a>* rte_pktmbuf_lastseg </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the last segment of the packet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last segment of the given mbuf. </dd></dl>

</div>
</div>
<a class="anchor" id="af714a7341cb37bc2530ac07c84c829b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rte_pktmbuf_pool_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mempool.html">rte_mempool</a> *&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opaque_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A packet mbuf pool constructor.</p>
<p>This function initializes the mempool private data in the case of a pktmbuf pool. This private data is needed by the driver. The function is given as a callback function to <a class="el" href="rte__mempool_8h.html#a7dc1d01a45144e3203c36d1800cb8f17">rte_mempool_create()</a> at pool creation. It can be extended by the user, for example, to provide another packet size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mp</td><td>The mempool from which mbufs originate. </td></tr>
    <tr><td class="paramname">opaque_arg</td><td>A pointer that can be used by the user to retrieve useful information for mbuf initialization. This pointer comes from the <code>init_arg</code> parameter of <a class="el" href="rte__mempool_8h.html#a7dc1d01a45144e3203c36d1800cb8f17">rte_mempool_create()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aadf5bef4ceb0b76dfafff0895f285ab0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char* rte_pktmbuf_prepend </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prepend len bytes to an mbuf data area.</p>
<p>Returns a pointer to the new data start address. If there is not enough headroom in the first segment, the function will return NULL, without modifying the mbuf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The pkt mbuf. </td></tr>
    <tr><td class="paramname">len</td><td>The amount of data to prepend (in bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the start of the newly prepended data, or NULL if there is not enough headroom space in the first segment </dd></dl>

</div>
</div>
<a class="anchor" id="a7ac5629940550649a2ef40029f5ad21a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_pktmbuf_refcnt_update </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds given value to the refcnt of all packet mbuf segments.</p>
<p>Walks through all segments of given packet mbuf and for each of them invokes <a class="el" href="rte__mbuf_8h.html#abb7eb5fa1599b7f6237040b95d8893de">rte_mbuf_refcnt_update()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf whose refcnt to be updated. </td></tr>
    <tr><td class="paramname">v</td><td>The value to add to the mbuf's segments refcnt. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc84d82d50361f568dd1d3a0e95d4aa4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rte_pktmbuf_reset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the fields of a packet mbuf to their default values.</p>
<p>The given mbuf must have only one segment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf to be resetted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a257bc8af3e8fde7eb6603bdf4ae0528e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t rte_pktmbuf_tailroom </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the tailroom of a packet mbuf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the tailroom. </dd></dl>

</div>
</div>
<a class="anchor" id="abe1bed439015acec170d1342e8dabb3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rte_pktmbuf_trim </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structrte__mbuf.html">rte_mbuf</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove len bytes of data at the end of the mbuf.</p>
<p>If the length is greater than the length of the last segment, the function will fail and return -1 without modifying the mbuf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The packet mbuf. </td></tr>
    <tr><td class="paramname">len</td><td>The amount of data to remove (in bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: On success.</li>
<li>-1: On error. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
