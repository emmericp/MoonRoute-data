-- vim:ts=4:sw=4:noexpandtab
--- This script can be used to determine if a device is affected by the corrupted packets
--  that are generated by the software rate control method.
--  It generates CBR traffic via both methods and compares the resulting latency distributions.
--  TODO: this module should also test L3 traffic (but not just L3 due to size constraints (timestamping limitations))
local dpdk		= require "dpdk"
local memory	= require "memory"
local ts		= require "timestamping"
local device	= require "device"
local filter	= require "filter"
local timer		= require "timer"
local stats		= require "stats"
local hist		= require "histogram"

-- required here because this script creates *a lot* of mempools
memory.enableCache()

local REPS = 10
local RUN_TIME = 20
local PKT_SIZE = 60

function master(...)
	local txPort, rxPort, maxRate, steps = tonumberall(...)
	if not txPort or not rxPort then
		errorf("usage: txPort rxPort [maxRate (Mpps)] [steps]")
	end
	local minRate = 0.02
	maxRate = maxRate or 7.44
	steps = (steps or 20) - 1
	local txDev = device.config(txPort, 2, 2)
	local rxDev = device.config(rxPort, 2, 2)
	local txQueue = txDev:getTxQueue(0)
	local txQueueTs = txDev:getTxQueue(1)
	local rxQueueTs = rxDev:getRxQueue(1)
	rxDev:l2Filter(0x1234, filter.DROP)
	device.waitForLinks()
	local results = {}
	for rate = minRate, maxRate, (maxRate - minRate) / steps do
		local result = {rate = rate, hardware = {{}, {}, {}}, software = {{}, {}, {}}}
		table.insert(results, result)
		for i = 1, REPS do
			for _, method in ipairs{"hardware", "software"} do
				printf("Testing rate %f Mpps with %s rate control, test run %d", rate, method, i)
				txQueue:setRateMpps(method == "hardware" and rate or 0)
				local loadTask = dpdk.launchLua("loadSlave", txQueue, rxDev, method == "software" and rate)
				local timerTask = dpdk.launchLua("timerSlave", txDev, rxDev, txQueueTs, rxQueueTs, ("%s-%s-%d"):format(method, rate, i))
				loadTask:wait()
				local quarts = { timerTask:wait() }
				for i, v in ipairs(quarts) do
					table.insert(result[method][i], v)
				end
				printf("\n")
				dpdk.sleepMillis(500)
			end
			if not dpdk.running() then
				break
			end
		end
		if not dpdk.running() then
			break
		end
	end
	printCsv("Rate", "Percentile", "Avg-SW", "Avg-HW", "StdDev-SW", "StdDev-HW")
	for i, r in ipairs(results) do
		for i, v in ipairs(r.software) do
			stats.addStats(v)
		end
		for i, v in ipairs(r.hardware) do
			stats.addStats(v)
		end
		printCsv(r.rate, "25", r.software[1].avg, r.hardware[1].avg, r.software[1].stdDev, r.hardware[1].stdDev)
		printCsv(r.rate, "50", r.software[2].avg, r.hardware[2].avg, r.software[2].stdDev, r.hardware[2].stdDev)
		printCsv(r.rate, "75", r.software[3].avg, r.hardware[3].avg, r.software[3].stdDev, r.hardware[3].stdDev)
	end
end

function loadSlave(queue, rxDev, rate)
	-- TODO: this leaks memory as mempools cannot be deleted in DPDK
	local mem = memory.createMemPool(function(buf)
		buf:getEthernetPacket():fill{
			ethType = 0x1234,
		}
	end)
	local bufs = mem:bufArray()
	local runtime = timer:new(RUN_TIME)
	local rxStats = stats:newDevRxCounter(rxDev, "plain")
	local txStats = stats:newDevTxCounter(queue, "plain")
	while runtime:running() and dpdk.running() do
		bufs:alloc(PKT_SIZE)
		if rate then
			for _, buf in ipairs(bufs) do
				buf:setRate(rate)
			end
			queue:sendWithDelay(bufs)
		else
			queue:send(bufs)
		end
		rxStats:update()
		txStats:update()
	end
	txStats:finalize()
	rxStats:finalize()
	local loss = txStats.total - rxStats.total
	printf("Packet loss: %d (%f%%)", loss, loss / txStats.total * 100)
end

function timerSlave(txDev, rxDev, txQueue, rxQueue, id)
	local timestamper = ts:newTimestamper(txQueue, rxQueue)
	local hist = hist:new()
	-- wait for a second to give the other task a chance to start
	-- TODO: maybe add sync points? but we don't want to start timestamping right away anyways
	dpdk.sleepMillis(1000)
	local runtime = timer:new(RUN_TIME - 2)
	local rateLimiter = timer:new(0.001)
	while runtime:running() and dpdk.running() do
		rateLimiter:reset()
		hist:update(timestamper:measureLatency(PKT_SIZE))
		-- keep the timestamping packets limited to about 1 kpps
		-- this is important when testing low rates
		rateLimiter:busyWait()
	end
	dpdk.sleepMillis(1500)
	hist:print()
	hist:save("hist-" .. id .. ".csv")
	return hist:quartiles()
end

