describe("IPv6 class", function()
	local pkt = require "packet"
	local ffi = require "ffi"
	it("should parse", function()
		local ip = parseIP6Address("0123:4567:89AB:CDEF:1011:1213:1415:1617")
		assert.are.same(ip.uint32[0], 0x14151617)
		assert.are.same(ip.uint32[1], 0x10111213)
		assert.are.same(ip.uint32[2], 0x89ABCDEF)
		assert.are.same(ip.uint32[3], 0x01234567)
	end)
	it("should parse shortened addresses", function()
		local short1 = parseIP6Address("::")
		local full1 = parseIP6Address("0000:0000:0000:0000:0000:0000:0000:0000")
		local short2 = parseIP6Address("1234:5678::")                             
		local full2 = parseIP6Address("1234:5678:0000:0000:0000:0000:0000:0000")
		local short3 = parseIP6Address("::89ab:cdef")                    
		local full3 = parseIP6Address("0000:0000:0000:0000:0000:0000:89ab:cdef")
		local short4 = parseIP6Address("1234:5678::89ab:cdef")                    
		local full4 = parseIP6Address("1234:5678:0000:0000:0000:0000:89ab:cdef")
		assert.are.same(short1, full1)
		assert.are.same(short2, full2)
		assert.are.same(short3, full3)
		assert.are.same(short4, full4)
	end)
	it("should return in correct byteorder", function()
		local ipString = "0123:4567:89ab:cdef:1011:1213:1415:1617"
		local ip =  ffi.new("union ip6_address")
		ip:setString(ipString)
		assert.are.same(ipString, ip:getString())

		-- internal representation (byteswap needed)
		local internal = parseIP6Address(ipString)
		assert.are.same(ipString, internal:getString(true))

	end)
	it("should support ==", function()
		local ip = ffi.new("union ip6_address")
		local ip2 = ffi.new("union ip6_address")
		local ip3 = ffi.new("union ip6_address")
		ip:setString("0123:4567:89AB:CDEF:1011:1213:1415:1617")
		ip2:setString("0123:4567:89AB:CDEF:1011:1213:1415:1617")
		ip3:setString("0123:4567:89AB:CDEF:1011:1213:1415:1618")
		assert.are.same(ip, ip2)
		assert.are.not_same(ip, ip3)
		assert.are.not_same(ip, 0)
		-- objects of different types should be equal, so don't implement this
		assert.are.not_same(parseIP6Address("0000:0000:0000:0000:0000:0000:0000:0000"), "0000:0000:0000:0000:0000:0000:0000:0000")
		assert.are.not_same(parseIP6Address("0000:0000:0000:0000:0000:0000:0000:0000"), 0)
	end)
	it("should do arithmetic", function()
		local ip = parseIP6Address("::") + 1
		assert.are.same(ip, parseIP6Address("::1"))
		ip = 0xFFFFFFFFFFFFFFFFULL + ip
		assert.are.same(ip, parseIP6Address("::1:0:0:0:0"))
		assert.are.same(ip + (-1), parseIP6Address("::ffff:ffff:ffff:ffff"))
		assert.are.same(ip - 1, parseIP6Address("::ffff:ffff:ffff:ffff"))
	end)
	it("should support in-place arithmetic", function()
		local ip1 = ffi.new("union ip6_address")
		local ip2 = ffi.new("union ip6_address")
		local ip3 = ffi.new("union ip6_address")
		local ip4 = ffi.new("union ip6_address")
		ip1:set(parseIP6Address("::1"))
		ip2:set(parseIP6Address("::2"))
		ip3:set(parseIP6Address("ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"))
		ip4:set(parseIP6Address("::1"))
		ip1:add(1)
		ip4:add(-2)
		assert.are.same(ip1, ip2)
		assert.are.same(ip3, ip4)
	end)

end)

