local ffi = require "ffi"
local dpdk = require "dpdk"
local serpent = require "Serpent"

ffi.cdef [[
struct mg_distribute_queue{
  uint16_t next_idx;
  uint16_t size;
  struct rte_mbuf *pkts[0];
};

struct mg_distribute_output{
  uint8_t valid;
  uint8_t port_id;
  uint16_t queue_id;
  uint64_t timeout;
  uint64_t time_first_added;
  struct mg_distribute_queue *queue;
};

struct mg_distribute_config{
  uint16_t entry_offset;
  uint16_t nr_outputs;
  uint8_t always_flush;
  struct mg_distribute_output outputs[0];
};


inline int8_t mg_distribute_enqueue(
  struct mg_distribute_queue * queue,
  struct rte_mbuf *pkt
  ){
  queue->pkts[queue->next_idx] = pkt;
  queue->next_idx++;
  // TODO: is switch here faster?
  // Attention: Order is relevant here, as a queue with size 1
  // should always trigger a flush and never timestamping
  if(unlikely(queue->next_idx == queue->size)){
    return 2;
  }
  if(unlikely(queue->next_idx == 1)){
    return 1;
  }
  return 0;
}

struct mg_distribute_config * mg_distribute_create(
    uint16_t entry_offset,
    uint16_t nr_outputs,
    uint8_t always_flush
    );

int mg_distribute_output_flush(
  struct mg_distribute_config *cfg,
  uint16_t number
  );

int mg_distribute_register_output(
  struct mg_distribute_config *cfg,
  uint16_t number,
  uint8_t port_id,
  uint16_t queue_id,
  uint16_t burst_size,
  uint64_t timeout
  );

int mg_distribute_send(
  struct mg_distribute_config *cfg,
  struct rte_mbuf **pkts,
  struct mg_bitmask* pkts_mask,
  void **entries
  );
int mg_distribute_send_single(
  struct mg_distribute_config *cfg,
  struct rte_mbuf *pkt,
  void **entry
  );

void mg_distribute_handle_timeouts(
  struct mg_distribute_config *cfg
  );
]]


local mod = {}

local mg_distribute = {}
mod.mg_distribute = mg_distribute
mg_distribute.__index = mg_distribute

--- Create a distributor instance.
-- A Distributor contains a redirection table and queues for every configured
-- output. On send() packets will be placed into the corresponding queue (which
-- is calculated using the provided routing table entry and the redirection
-- table). Queues will be emptied and sent to the wire, when they are full or
-- when their timeout is hit. Optionally the queue can be forced to be flushed
-- after every send() invocation.
-- @param socket Cpu socket at which to allocate memory for the distributor
-- @param entryOffset Offset in bytes, where to find the interface number
--  in each routing table entry
-- @param nrOutputs The maximum number of output devices/queues this distributor
--  will support
-- @param always_flush if true, the output queues will be sent out after every
--  call to send()
-- @return the newly created distributor instance
function mod.createDistributor(socket, entryOffset, nrOutputs, alwaysFlush)
  socket = socket or select(2, dpdk.getCore())
  entryOffset = entryOffset or 0
  if alwaysFlush then
    alwaysFlush = 1
  else
    alwaysFlush = 0
  end

  return setmetatable({
    cfg = ffi.C.mg_distribute_create(entryOffset, nrOutputs, alwaysFlush),
    socket = socket
  }, mg_distribute)
end

--- Free the distributor
function mg_distribute:free()
  ffi.C.mg_NOT_YET_IMPLEMENTED(self.cfg) -- FIXME
end

function mg_distribute:__serialize()
	return "require 'distribute'; return " .. serpent.addMt(serpent.dumpRaw(self), "require('distribute').mg_distribute"), true
end

--- Send packets.
-- @param packets A buffer array containing packets to be sent
-- @param bitMask a bitMask specifying which packets in the buffer array to
--  be sent
-- @param routingEntries Routing table entries for the packets (usually
--  generated by the lpm:lookup() function)
-- @return always 0
function mg_distribute:send(packets, bitMask, routingEntries)
  return ffi.C.mg_distribute_send(self.cfg, packets.array, bitMask.bitmask, ffi.cast("void **", routingEntries.array))
end

--- Send a single packet.
-- @param a mbuf containing the packet
-- @param routingEntry the routing table entry describing the packets destination
function mg_distribute:send_single(packet, routingEntry)
  return ffi.C.mg_distribute_send_single(self.cfg, packet, ffi.cast("void **", routingEntry.array))
end

--- Register an Output.
--  Associates an outputNumber to a transmit queue (found in the
--  routing table entry). And configures the distributor queue parameters
-- @param outputNumber Number found in the routing table entry, which will be
--  associated to this transmit queue
-- @param txQueue nic tx queue, where packets for this output Number will be sent out
-- @param bufferSize Size of the distributor buffer for this output in number of packets
-- @param timeout Timeout in seconds for this output queue. A timer will be
--  started, when the first packet is put into the queue and the qhole queue
--  will be flushed if the timer hits the timeout
function mg_distribute:registerOutput(outputNumber, txQueue, bufferSize, timeout)
  -- FIXME: is this a good idea, to use uint64_t bit integers in lua??
  local f_cpu = dpdk.getCyclesFrequency()
  local cycles_timeout = tonumber(f_cpu * timeout)

  local portID = txQueue.id
  local queueID = txQueue.qid

  print ("    register output NR " .. tostring(outputNumber) .. " -> port = " .. tostring(portID) .. " queue = " .. tostring(queueID) .. " timeout = " .. tostring(cycles_timeout))
  ffi.C.mg_distribute_register_output(self.cfg, outputNumber, portID, queueID, bufferSize, cycles_timeout)
end

--- Handle distributor timeouts.
-- This function must be called periodically. If invoked, it will check if
-- queues have to be flushed and perform the flush if neccessary.
-- If this function is not called, the timeouts for the outputs will not work.
function mg_distribute:handleTimeouts()
  ffi.C.mg_distribute_handle_timeouts(self.cfg)
  return
end

return mod
